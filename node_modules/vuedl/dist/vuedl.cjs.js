'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Vue = _interopDefault(require('vue'));
var merge = _interopDefault(require('lodash/merge'));
var Debug = _interopDefault(require('debug'));

var Recordable = {
  computed: {
    $parameters: function $parameters() {
      return this.$options.propsData;
    },

    isNewRecord: function () {
      return !this.$options.primaryKey || !this.$options.propsData || !this.$options.propsData[this.$options.primaryKey];
    }
  }
};

var Activable = {
  name: 'Activable',

  data: function data() {
    return {
      isActive: false
    };
  },

  watch: {
    isActive: function isActive(val) {
      // debugger
      // if (this.isLayout) {
      // this.$children.forEach(vm => {
      //   if (vm.isActive !== undefined) {
      //     vm.isActive = val
      //   }
      // })
      if (this._dialogInstance) {
        if (this._dialogInstance.isActive !== undefined) {
          this._dialogInstance.isActive = val;
        }
      } else {
        if (this.$parent && this.$parent.isActive !== undefined) {
          this.$parent.isActive = val;
        }
      }
    }

  },
  methods: {
    close: function close() {
      this.isActive = false;
    }

  }
};

var Layoutable = {
  name: 'Layoutable',
  mixins: [Activable],
  props: {
    width: {
      type: Number,
      default: function () { return 450; }
    },
    persistent: Boolean
  },

  data: function data() {
    return {
      loading: false
    };
  },

  compouted: {
    isLayout: function isLayout() {
      return true;
    }

  },
  watch: {
    isActive: function isActive(val) {
      if (!val) {
        // window.removeEventListener('popstate', this.close)
        this._destroy();
      }
    }

  },

  mounted: function mounted() {
    // this.$nextTick(() => {
    // window.addEventListener('popstate', this.close)
    // })
    this.isActive = true;
  },

  methods: {
    _destroy: function _destroy() {
      this.$destroy();
    },

    dismiss: function dismiss() {
      if (!this.persistent && !this.loading) {
        this.isActive = false;
      }
    },

    close: function close() {
      this.isActive = false;
    }

  },

  beforeDestroy: function beforeDestroy() {
    if (typeof this.$el.remove !== 'undefined') {
      this.$el.remove();
    } else {
      this.$el.parentNode.removeChild(this.$el);
    }
  }

};

//
//
//
//
//
//
var script = {};

/* script */
            var __vue_script__ = script;
            
/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "dialog-layout" }, [_vm._t("default")], 2)
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = undefined;
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* component normalizer */
  function __vue_normalize__(
    template, style, script$$1,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DefaultLayout.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    

    return component
  }
  /* style inject */
  function __vue_create_injector__() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var DefaultLayout = __vue_normalize__(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    __vue_create_injector__,
    undefined
  )

/*
 * vuedl
 *
 * (c) Savaryn Yaroslav <yariksav@gmail.com>
 *
 * Some functions was imported from nuxt.js/lib/app/utils.js
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/

var noopData = function () { return ({}); };

function promisify(fn, context) {
  var promise;

  if (fn.length === 2) {
    // fn(context, callback)
    promise = new Promise(function (resolve) {
      fn(context, function (err, data) {
        if (err) {
          context.error(err);
        }

        data = data || {};
        resolve(data);
      });
    });
  } else {
    promise = fn(context);
  }

  if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {
    promise = Promise.resolve(promise);
  }

  return promise;
}
function destroyVueElement(vm) {
  if (vm && !vm._isDestroyed && typeof vm.$destroy === 'function') {
    vm.$destroy();
  }
}
function findContainer(container) {
  var found;

  if (typeof container === 'string') {
    found = document.querySelector(container);
  } else {
    found = container;
  }

  if (!found) {
    found = document.body;
  }

  return found;
}
function applyAsyncData(Component, asyncData) {
  var ComponentData = Component.options.data || noopData; // Prevent calling this method for each request on SSR context

  if (!asyncData && Component.options.hasAsyncData) {
    return;
  }

  Component.options.hasAsyncData = true;

  Component.options.data = function () {
    var data = ComponentData.call(this);

    if (this.$ssrContext) {
      asyncData = this.$ssrContext.asyncData[Component.cid];
    }

    return Object.assign({}, data, asyncData);
  };

  if (Component._Ctor && Component._Ctor.options) {
    Component._Ctor.options.data = Component.options.data;
  }
}
function ensureAsyncDatas(components, context) {
  return new Promise(function ($return, $error) {
    if (!Array.isArray(components)) {
      if (!components) {
        return $return(null);
      } else {
        components = [components];
      }
    }

    return $return(Promise.all(components.map(function (Component) {
      var promises = []; // Call asyncData(context)

      if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {
        var promise = promisify(Component.options.asyncData, context);
        promise.then(function (asyncDataResult) {
          // ssrContext.asyncData[Component.cid] = asyncDataResult
          applyAsyncData(Component, asyncDataResult);
          return asyncDataResult;
        });
        promises.push(promise);
      } else {
        promises.push(null);
      } // Call fetch(context)


      if (Component.options.fetch) {
        promises.push(Component.options.fetch(context));
      } else {
        promises.push(null);
      }

      return Promise.all(promises);
    })));
  });
}

/*
 * vuedl
 *
 * (c) Savaryn Yaroslav <yariksav@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var debug = Debug('vuedl:dialog');
var seed = 1;
var Dialog = function Dialog(component, ref) {
  if ( ref === void 0 ) ref = {};
  var layout = ref.layout;
  var container = ref.container;

  if (!component) {
    throw Error('Component was not setted');
  }

  this._layout = layout || {
    component: DefaultLayout,
    options: {}
  };
  this._component = component;
  this._vm = null;
  this._vmDialog = null;
  this._options = {};
  this.id = ++seed;
  this._resolvers = [];
  this.container = findContainer(container);
  debug('created');
};

var prototypeAccessors = { showed: { configurable: true },element: { configurable: true },hasAsyncPreload: { configurable: true },vm: { configurable: true },vmd: { configurable: true } };

Dialog.prototype.show = function show (params, options) {
    if ( params === void 0 ) params = {};
    if ( options === void 0 ) options = {};

  return new Promise(function ($return, $error) {
    var LayoutCtor, layout, DialogCtor, dialog;
    if (Vue.prototype.$isServer) { return $return(); }
    debug('before show', {
      params: params,
      options: options
    }); // create layout

    LayoutCtor = Vue.extend(this._layout.component);
    LayoutCtor = LayoutCtor.extend({
      mixins: [Layoutable],
      destroyed: this._onDestroyed.bind(this)
    });
    layout = new LayoutCtor(merge({
      propsData: Object.assign({}, this._layout.options, params)
    }, this.context, options));
    DialogCtor = Vue.extend(Object.assign({}, this._component, {
      parent: layout
    }));

    if (this._component.primaryKey) {
      DialogCtor = DialogCtor.extend({
        mixins: [Recordable]
      });
    }

    if (this.hasAsyncPreload) {
      var res;
      return Promise.resolve(ensureAsyncDatas(DialogCtor, Object.assign({}, this.context, {
        params: params
      }))).then(function ($await_2) {
        try {
          res = $await_2;
          debug('async datas', res);
          return $If_1.call(this);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }

    function $If_1() {
      dialog = new DialogCtor(merge({
        propsData: params
      }, this.context, options));
      // mounting
      dialog.$mount();
      layout.$slots.default = dialog._vnode;
      layout.$mount();
      layout.$on('submit', this.onReturn.bind(this));
      dialog.$on('submit', this.onReturn.bind(this));
      this._vm = layout;
      this._vm._dialogInstance = dialog;
      this._vmDialog = dialog;
      this.container = options.container ? findContainer(options.container) : this.container;
      this.container.appendChild(this.element);
      return $return(this);
    }

    return $If_1.call(this);
  }.bind(this));
};

Dialog.prototype.wait = function wait () {
    var this$1 = this;

  // if (!this.showed) {
  // return Promise.reject(new Error('Dialog was closed or not showed'))
  // }
  return new Promise(function (resolve) {
    this$1._resolvers.push(resolve);
  });
};

Dialog.prototype._onDestroyed = function _onDestroyed () {
  this.remove();
};

Dialog.prototype.remove = function remove () {
  debug('remove');
  this.onDestroyed && this.onDestroyed(this); // this.element.parentNode.removeChild(this.element)

  this._processResultPromises();

  destroyVueElement(this._vm);
  destroyVueElement(this._vmDialog);
  this._vm = null;
  this._vmDialog = null;
};

Dialog.prototype._processResultPromises = function _processResultPromises (result) {
  if (!this._resolvers.length) {
    return;
  }

  debug('processResultPromises', result);

  this._resolvers.forEach(function (resolver) { return resolver(result); });

  this._resolvers = [];
};

Dialog.prototype.onReturn = function onReturn (result) {
  debug('onReturn', result);

  this._processResultPromises(result);

  this.close();
};

prototypeAccessors.showed.get = function () {
  return !!this._vm && !this._vm._isDestroyed;
};

prototypeAccessors.element.get = function () {
  return this._vm && this._vm.$el;
};

prototypeAccessors.hasAsyncPreload.get = function () {
  return this._component && (this._component.asyncData || this._component.fetch);
};

prototypeAccessors.vm.get = function () {
  return this._vm;
};

prototypeAccessors.vmd.get = function () {
  return this._vmDialog;
};

Dialog.prototype.close = function close () {
  this._vm.close();
};

Object.defineProperties( Dialog.prototype, prototypeAccessors );

/*
 * vuedl
 *
 * (c) Savaryn Yaroslav <yariksav@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var Overlay = function Overlay(component) {
  this._component = component;
  this._vm = null;
};

Overlay.prototype.show = function show () {
  if (!this._vm) {
    var Ctor = Vue.extend(this._component);
    this._vm = new Ctor(); // {propsData: { visible: true }}

    this._vm.$mount();

    document.body.appendChild(this._vm.$el);
  }

  this._vm.visible = true;
};

Overlay.prototype.hide = function hide () {
  this._vm.visible = false;
};

/*
 * vuedl
 *
 * (c) Savaryn Yaroslav <yariksav@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/

var proxyHandler = {
  get: function get(target, name) {
    /**
     * if node is inspecting then stick to target properties
     */
    if (typeof name === 'symbol' || name === 'inspect') {
      return target[name];
    }

    if (target[name]) {
      return target[name];
    }

    if (target._components[name]) {
      return target.createFunctionWrapper(name);
    }

    return target[name];
  }

};
var DialogManager = function DialogManager(ref) {
  if ( ref === void 0 ) ref = {};
  var context = ref.context;
  var container = ref.container;

  this._context = context || {};
  Dialog.prototype.context = context || {};
  this._components = {};
  this._layouts = {};
  this._overlays = {};
  this._container = container;
  this._emitter = new Vue({});
  this._instances = []; // this.initEmitter()

  return new Proxy(this, proxyHandler);
};

var prototypeAccessors$1 = { context: { configurable: true } }; // initEmitter () {
// this._emitter.$on('shown', ({ dialog }) => {
//   const position = dialog.vm.position
//   let verticalOffset = notificationGap
//   this._instances.filter(item => item.vm.position === position).forEach(item => {
//     verticalOffset += item.element.offsetHeight + notificationGap
//   })
//   this._instances.push(dialog)
//   dialog.vm.verticalOffset = verticalOffset
// })
// this._emitter.$on('destroyed', ({ dialog }) => {
//   let index = this._instances.findIndex(instance => instance.id === dialog.id)
//   if (index < 0) {
//     return
//   }
//   this._instances.splice(index, 1)
//   // console.log('instances', this._instances)
//   const len = this._instances.length
//   const position = dialog.vm.position
//   if (!len) return
//   let verticalOffset = notificationGap
//   this._instances.filter(item => item.vm.position === position).forEach(item => {
//     item.vm.verticalOffset = verticalOffset
//     verticalOffset += item.element.offsetHeight + notificationGap
//   })
// })
// }


prototypeAccessors$1.context.get = function () {
  return this._context;
};

DialogManager.prototype.layout = function layout (name, component, options) {
    if ( options === void 0 ) options = {};

  this._layouts[name] = {
    component: component,
    options: options
  };
};

DialogManager.prototype.getLayout = function getLayout (layout) {
  if (typeof layout === 'function') {
    var options = layout.call(this);
    layout = this._layouts[options.name || 'default'];
    return Object.assign({}, layout, {
      options: options
    });
  }

  if (typeof layout === 'object' && typeof layout.render === 'function') {
    return {
      component: layout
    };
  }

  if (Array.isArray(layout)) {
    var nameTmp = layout[0];
    var optionsTmp = layout[1] || {};
    var instance = typeof nameTmp === 'object' && typeof nameTmp.render === 'function' ? {
      component: nameTmp
    } : this._layouts[nameTmp];
    return instance && {
      component: instance.component,
      options: Object.assign({}, instance.options, optionsTmp)
    };
  }

  return this._layouts[layout];
};

DialogManager.prototype.overlay = function overlay (name, component) {
  if (component === undefined) {
    if (this._overlays[name]) {
      return this._overlays[name];
    } else {
      throw new Error(("Overlay \"" + name + " not found\n          Please register it by calling dialog.overlay('" + name + "', component)"));
    }
  }

  this._overlays[name] = new Overlay(component);
};

DialogManager.prototype.getComponent = function getComponent (name) {
  if (!this._components[name]) {
    throw new Error(("Component \"" + name + "\" was not found.\n        Please register it by calling dialog.register('" + name + "', component)"));
  }

  return this._components[name];
};

DialogManager.prototype.component = function component (name, component$1, options) {
    if ( options === void 0 ) options = {};

  if (component$1 === undefined) {
    return this._components[name];
  }

  this._components[name] = {
    component: component$1,
    options: options
  };
};

DialogManager.prototype.create = function create (component) {
  if (!component) {
    throw new Error('Component is incorrect');
  }

  var layout = this.getLayout(component.layout || 'default');
  var dlg = new Dialog(component, {
    layout: layout,
    context: this._context,
    container: this._container
  });

  this._emitter.$emit('created', {
    dialog: dlg
  });

  return dlg;
};

DialogManager.prototype.show = function show (component, options) {
    if ( options === void 0 ) options = {};

  return new Promise(function ($return, $error) {
    var dlg, overlayName, overlay;
    dlg = this.create(component);
    overlayName = dlg.hasAsyncPreload ? component.overlay || 'default' : false;
    overlay = overlayName && this._overlays[overlayName] && this.overlay(overlayName);
    overlay && overlay.show();

    var $Try_1_Catch = function (e) {
      try {
        this._emitter.$emit('error', {
          error: e,
          dialog: dlg
        });

        overlay && overlay.hide();
        throw e;
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }.bind(this);

    try {
      return Promise.resolve(dlg.show(options)).then(function ($await_2) {
        try {
          this._emitter.$emit('shown', {
            dialog: dlg
          });

          overlay && overlay.hide();
          dlg.onDestroyed = this.onDialogDestroyed.bind(this);
          return $return(options.waitForResult ? dlg.wait() : dlg);
        } catch ($boundEx) {
          return $Try_1_Catch($boundEx);
        }
      }.bind(this), $Try_1_Catch);
    } catch (e) {
      $Try_1_Catch(e);
    }
  }.bind(this));
};

DialogManager.prototype.createFunctionWrapper = function createFunctionWrapper (name) {
    var this$1 = this;

  var cmp = this.getComponent(name);
  return function (options) { return this$1.show(cmp.component, Object.assign({}, cmp.options, options)); };
};

DialogManager.prototype.showAndWait = function showAndWait (component, props) {
  return new Promise(function ($return, $error) {
    var dlg;
    return Promise.resolve(this.show(component, props)).then(function ($await_3) {
      try {
        dlg = $await_3;
        return $return(dlg.wait());
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  }.bind(this));
};

DialogManager.prototype.on = function on (event, callback) {
  this._emitter.$on(event, callback);
};

DialogManager.prototype.off = function off (event, callback) {
  this._emitter.$off(event, callback);
};

DialogManager.prototype.once = function once (event, callback) {
  this._emitter.$once(event, callback);
};

DialogManager.prototype.onDialogDestroyed = function onDialogDestroyed (dialog) {
  this._emitter.$emit('destroyed', {
    dialog: dialog
  });
};

Object.defineProperties( DialogManager.prototype, prototypeAccessors$1 );

//
//
//
//
//
//
//
//
//
//
var script$1 = {
  props: {
    width: Number,
    persistent: Boolean
  }
};

/* script */
            var __vue_script__$1 = script$1;
            
/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { name: "vdialog-modal" } }, [
    _c(
      "div",
      {
        staticClass: "vdialog-modal-mask",
        on: {
          click: function($event) {
            if ($event.target !== $event.currentTarget) {
              return null
            }
            $event.preventDefault();
            $event.stopPropagation();
            return _vm.dismiss($event)
          }
        }
      },
      [
        _c(
          "div",
          {
            staticClass: "vdialog-modal-container",
            style: { "max-width": (_vm.width || 500) + "px" }
          },
          [
            _c(
              "dialog-child",
              _vm._b({}, "dialog-child", _vm.$options.propsData, false)
            )
          ],
          1
        )
      ]
    )
  ])
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$1 = function (inject) {
    if (!inject) { return }
    inject("data-v-5c224c04_0", { source: "\n.vdialog-modal-mask {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  position: fixed;\n  top: 0;\n  transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\n  width: 100%;\n  z-index: 6;\n  outline: none;\n  background-color: rgba(0, 0, 0, .5);\n}\n.vdialog-modal-container {\n  overflow-y: auto;\n  max-height: 95%;\n  background-color: #fff;\n  box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\n  border-radius: 2px;\n  margin: 12px;\n  overflow-y: auto;\n  pointer-events: auto;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n  width: 100%;\n  z-index: inherit;\n}\n\n/*\n* The following styles are auto-applied to elements with\n* transition=\"modal\" when their visibility is toggled\n* by Vue.js.\n*\n* You can easily play with the modal transition by editing\n* these styles.\n*/\n.vdialog-modal-enter {\n  opacity: 0;\n}\n.vdialog-modal-leave-active {\n  opacity: 0;\n}\n.vdialog-modal-enter .modal-container,\n.vdialog-modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue"],"names":[],"mappings":";AAqBA;EACA,oBAAA;EACA,cAAA;EACA,aAAA;EACA,wBAAA;EACA,QAAA;EACA,gBAAA;EACA,OAAA;EACA,kDAAA;EACA,YAAA;EACA,WAAA;EACA,cAAA;EACA,oCAAA;CACA;AAEA;EACA,iBAAA;EACA,gBAAA;EACA,uBAAA;EACA,sHAAA;EACA,mBAAA;EACA,aAAA;EACA,iBAAA;EACA,qBAAA;EACA,kDAAA;EACA,YAAA;EACA,iBAAA;CACA;;AAEA;;;;;;;EAOA;AAEA;EACA,WAAA;CACA;AAEA;EACA,WAAA;CACA;AAEA;;EAEA,8BAAA;EACA,sBAAA;CACA","file":"DialogLayout.vue","sourcesContent":["<template>\n  <transition name=\"vdialog-modal\">\n    <div class=\"vdialog-modal-mask\" @click.self.prevent.stop=\"dismiss\">\n        <div class=\"vdialog-modal-container\" :style=\"{ 'max-width': (width || 500) +'px' }\">\n          <dialog-child v-bind=\"$options.propsData\"/>\n        </div>\n    </div>\n  </transition>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    width: Number,\n    persistent: Boolean\n  }\n}\n</script>\n\n<style>\n  .vdialog-modal-mask {\n    align-items: center;\n    display: flex;\n    height: 100%;\n    justify-content: center;\n    left: 0;\n    position: fixed;\n    top: 0;\n    transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\n    width: 100%;\n    z-index: 6;\n    outline: none;\n    background-color: rgba(0, 0, 0, .5);\n  }\n\n  .vdialog-modal-container {\n    overflow-y: auto;\n    max-height: 95%;\n    background-color: #fff;\n    box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\n    border-radius: 2px;\n    margin: 12px;\n    overflow-y: auto;\n    pointer-events: auto;\n    transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n    width: 100%;\n    z-index: inherit;\n  }\n\n  /*\n  * The following styles are auto-applied to elements with\n  * transition=\"modal\" when their visibility is toggled\n  * by Vue.js.\n  *\n  * You can easily play with the modal transition by editing\n  * these styles.\n  */\n\n  .vdialog-modal-enter {\n    opacity: 0;\n  }\n\n  .vdialog-modal-leave-active {\n    opacity: 0;\n  }\n\n  .vdialog-modal-enter .modal-container,\n  .vdialog-modal-leave-active .modal-container {\n    -webkit-transform: scale(1.1);\n    transform: scale(1.1);\n  }\n</style>\n"]}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = false;
  /* component normalizer */
  function __vue_normalize__$1(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    {
      var hook;
      if (style) {
        hook = function(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;
          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context)
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component
  }
  /* style inject */
  function __vue_create_injector__$1() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var DialogLayout = __vue_normalize__$1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    __vue_create_injector__$1,
    undefined
  )

var notifications = [];
var gap = 10;

var insertNotification = function (vm) {
  var position = vm.position;
  var verticalOffset = gap;
  notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {
    verticalOffset += item.$el.offsetHeight + gap;
  });
  notifications.push(vm);
  vm.verticalOffset = verticalOffset;
};

var deleteNotification = function (vm) {
  var index = notifications.findIndex(function (instance) { return instance === vm; });

  if (index < 0) {
    return;
  }

  notifications.splice(index, 1);
  var len = notifications.length;
  var position = vm.position;
  if (!len) { return; }
  var verticalOffset = gap;
  notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {
    item.verticalOffset = verticalOffset;
    verticalOffset += item.$el.offsetHeight + gap;
  });
};

var Notifiable = {
  props: {
    verticalOffset: Number,
    showClose: {
      type: Boolean,
      default: function () { return true; }
    },
    position: {
      type: String,
      default: function () { return 'top-right'; }
    },
    timeout: {
      type: Number,
      default: function () { return 4500; }
    },
    width: {
      type: Number,
      default: function () { return 330; }
    },
    zIndex: {
      type: Number,
      default: function () { return 2000; }
    }
  },
  computed: {
    horizontalClass: function horizontalClass() {
      return this.position.indexOf('right') > -1 ? 'right' : 'left';
    },

    verticalProperty: function verticalProperty() {
      return /^top-/.test(this.position) ? 'top' : 'bottom';
    },

    getStyle: function getStyle() {
      var obj;

      return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + "px"), obj['max-width'] =  ((this.width) + "px"), obj['z-index'] =  this.zIndex, obj);
    }

  },
  methods: {
    _destroy: function _destroy() {
      this.$el.addEventListener('transitionend', this.onTransitionEnd);
    },

    onTransitionEnd: function onTransitionEnd() {
      this.$el.removeEventListener('transitionend', this.onTransitionEnd);
      this.$destroy();
    },

    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
    },

    startTimer: function startTimer() {
      if (this.timeout > 0) {
        this.timer = setTimeout(this.close, this.timeout);
      }
    },

    keydown: function keydown(e) {
      if (e.keyCode === 46 || e.keyCode === 8) {
        this.clearTimer(); // detele key
      } else if (e.keyCode === 27) {
        // esc key
        this.close();
      } else {
        this.startTimer(); // any key
      }
    },

    close: function close() {
      this.isActive = false;
    }

  },
  watch: {
    isActive: function isActive(val) {
      if (val) {
        insertNotification(this);
      } else {
        deleteNotification(this);
      }
    }

  },

  mounted: function mounted() {
    this.startTimer();
    document.addEventListener('keydown', this.keydown);
  },

  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('keydown', this.keydown);
  }

};

//
var script$2 = {
  mixins: [Notifiable],
  props: {
    //   showClose: {
    //     type: Boolean,
    //     default: () => true
    //   },
    width: {
      type: Number,
      default: function () { return 330; }
    }
  },
  computed: {
    getStyle: function getStyle() {
      var obj;

      return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + "px"), obj['max-width'] =  ((this.width) + "px"), obj['z-index'] =  this.zIndex, obj);
    }

  } // methods: {
  //   _destroy () {
  //     this.$el.addEventListener('transitionend', this.onTransitionEnd)
  //   },
  //   onTransitionEnd () {
  //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)
  //     this.$destroy()
  //   }
  // }

};

/* script */
            var __vue_script__$2 = script$2;
            
/* template */
var __vue_render__$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { name: "vuedl-notification-fade" } }, [
    _c(
      "div",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.isActive,
            expression: "isActive"
          }
        ],
        class: ["vuedl-notification", _vm.horizontalClass],
        style: _vm.getStyle,
        attrs: { role: "alert" },
        on: { mouseenter: _vm.clearTimer, mouseleave: _vm.startTimer }
      },
      [
        _vm._t("default"),
        _vm._v(" "),
        _vm.showClose
          ? _c(
              "div",
              {
                staticClass: "vuedl-notification__closeBtn",
                on: {
                  click: function($event) {
                    $event.stopPropagation();
                    return _vm.close($event)
                  }
                }
              },
              [_vm._v("×")]
            )
          : _vm._e()
      ],
      2
    )
  ])
};
var __vue_staticRenderFns__$2 = [];
__vue_render__$2._withStripped = true;

  /* style */
  var __vue_inject_styles__$2 = function (inject) {
    if (!inject) { return }
    inject("data-v-f0792652_0", { source: "\n.vuedl-notification {\n   display:-webkit-box;\n   display:-ms-flexbox;\n   display:flex;\n   -webkit-box-sizing:border-box;\n   box-sizing:border-box;\n   position:fixed;\n   -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n   box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n   -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   overflow:hidden\n}\n.vuedl-notification>div:first-child {\n   width: 100%\n}\n.vuedl-notification.right {\n   right:16px\n}\n.vuedl-notification.left {\n   left:16px\n}\n.vuedl-notification__closeBtn {\n   position:absolute;\n   top: 9px;\n   right: 15px;\n   cursor: pointer;\n   color: #909399;\n   font-size: 22px;\n}\n.vuedl-notification__closeBtn:hover {\n   color:#606266\n}\n.vuedl-notification-fade-enter.right{\n   right:0;\n   -webkit-transform:translateX(100%);\n   transform:translateX(100%)\n}\n.vuedl-notification-fade-enter.left{\n   left:0;\n   -webkit-transform:translateX(-100%);\n   transform:translateX(-100%)\n}\n.vuedl-notification-fade-leave-active {\n   opacity:0\n}\n@media screen and (max-width: 450px) {\n.vuedl-notification {\n     left:8px!important;\n     right:8px!important;\n     max-width: inherit!important;\n}\n}\n\n/* .el-notification-fade-enter {\n   &.right {\n     right: 0;\n     transform: translateX(100%);\n   }\n\n   &.left {\n     left: 0;\n     transform: translateX(-100%);\n   }\n }\n\n .el-notification-fade-leave-active {\n   opacity: 0;\n }*/\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue"],"names":[],"mappings":";AAwDA;GACA,oBAAA;GACA,oBAAA;GACA,aAAA;GACA,8BAAA;GACA,sBAAA;GACA,eAAA;GACA,+CAAA;GACA,uCAAA;GACA,2FAAA;GACA,mFAAA;GACA,2EAAA;GACA,iGAAA;GACA,eAAA;CACA;AACA;GACA,WAAA;CACA;AACA;GACA,UAAA;CACA;AACA;GACA,SAAA;CACA;AACA;GACA,kBAAA;GACA,SAAA;GACA,YAAA;GACA,gBAAA;GACA,eAAA;GACA,gBAAA;CACA;AACA;GACA,aAAA;CACA;AACA;GACA,QAAA;GACA,mCAAA;GACA,0BAAA;CACA;AACA;GACA,OAAA;GACA,oCAAA;GACA,2BAAA;CACA;AACA;GACA,SAAA;CACA;AACA;AACA;KACA,mBAAA;KACA,oBAAA;KACA,6BAAA;CACA;CACA;;AAEA;;;;;;;;;;;;;;IAcA","file":"NotificationLayout.vue","sourcesContent":["<template>\n  <transition name=\"vuedl-notification-fade\">\n    <div\n      :class=\"['vuedl-notification', horizontalClass]\"\n      v-show=\"isActive\"\n      :style=\"getStyle\"\n      @mouseenter=\"clearTimer\"\n      @mouseleave=\"startTimer\"\n      role=\"alert\"\n    >\n      <slot/>\n      <div\n        class=\"vuedl-notification__closeBtn\"\n        v-if=\"showClose\"\n        @click.stop=\"close\">×</div>\n    </div>\n  </transition>\n</template>\n\n<script>\n\nimport Notifiable from '../mixins/notifiable'\n\nexport default {\n  mixins: [ Notifiable ],\n  props: {\n  //   showClose: {\n  //     type: Boolean,\n  //     default: () => true\n  //   },\n    width: {\n      type: Number,\n      default: () => 330\n    }\n  },\n  computed: {\n    getStyle () {\n      return {\n        [this.verticalProperty]: `${this.verticalOffset}px`,\n        'max-width': `${this.width}px`,\n        'z-index': this.zIndex\n      }\n    }\n  }\n  // methods: {\n  //   _destroy () {\n  //     this.$el.addEventListener('transitionend', this.onTransitionEnd)\n  //   },\n  //   onTransitionEnd () {\n  //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)\n  //     this.$destroy()\n  //   }\n  // }\n}\n</script>\n<style>\n  .vuedl-notification {\n    display:-webkit-box;\n    display:-ms-flexbox;\n    display:flex;\n    -webkit-box-sizing:border-box;\n    box-sizing:border-box;\n    position:fixed;\n    -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n    box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n    -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    overflow:hidden\n  }\n  .vuedl-notification>div:first-child {\n    width: 100%\n  }\n  .vuedl-notification.right {\n    right:16px\n  }\n  .vuedl-notification.left {\n    left:16px\n  }\n  .vuedl-notification__closeBtn {\n    position:absolute;\n    top: 9px;\n    right: 15px;\n    cursor: pointer;\n    color: #909399;\n    font-size: 22px;\n  }\n  .vuedl-notification__closeBtn:hover {\n    color:#606266\n  }\n  .vuedl-notification-fade-enter.right{\n    right:0;\n    -webkit-transform:translateX(100%);\n    transform:translateX(100%)\n  }\n  .vuedl-notification-fade-enter.left{\n    left:0;\n    -webkit-transform:translateX(-100%);\n    transform:translateX(-100%)\n  }\n  .vuedl-notification-fade-leave-active {\n    opacity:0\n  }\n  @media screen and (max-width: 450px) {\n    .vuedl-notification {\n      left:8px!important;\n      right:8px!important;\n      max-width: inherit!important;\n    }\n  }\n\n /* .el-notification-fade-enter {\n    &.right {\n      right: 0;\n      transform: translateX(100%);\n    }\n\n    &.left {\n      left: 0;\n      transform: translateX(-100%);\n    }\n  }\n\n  .el-notification-fade-leave-active {\n    opacity: 0;\n  }*/\n</style>\n"]}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = false;
  /* component normalizer */
  function __vue_normalize__$2(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    {
      var hook;
      if (style) {
        hook = function(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;
          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context)
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component
  }
  /* style inject */
  function __vue_create_injector__$2() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var NotificationLayout = __vue_normalize__$2(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    __vue_create_injector__$2,
    undefined
  )

//
//
//
//
//
var script$3 = {
  name: 'VDialogOverlay',
  props: {
    zIndex: {
      type: Number,
      default: function () { return 1250; }
    },
    visible: {
      type: Boolean,
      default: function () { return false; }
    }
  }
};

/* script */
            var __vue_script__$3 = script$3;
            
/* template */
var __vue_render__$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { name: "opacity" } }, [
    _vm.visible
      ? _c(
          "div",
          {
            staticClass: "dialog-overlay-loading",
            style: { zIndex: _vm.zIndex }
          },
          [_vm._v("Loading…")]
        )
      : _vm._e()
  ])
};
var __vue_staticRenderFns__$3 = [];
__vue_render__$3._withStripped = true;

  /* style */
  var __vue_inject_styles__$3 = function (inject) {
    if (!inject) { return }
    inject("data-v-05d353e2_0", { source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Absolute Center Spinner */\n.dialog-overlay-loading {\n  position: fixed;\n  z-index: 999;\n  height: 2em;\n  width: 2em;\n  overflow: show;\n  margin: auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  /* background: rgba(112, 112, 112, 0.4); */\n  cursor: wait;\n}\n\n/* Transparent Overlay */\n.dialog-overlay-loading:before {\n  content: '';\n  display: block;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n}\n\n/* :not(:required) hides these rules from IE9 and below */\n.dialog-overlay-loading:not(:required) {\n  /* hide \"loading...\" text */\n  font: 0/0 a;\n  color: transparent;\n  text-shadow: none;\n  background-color: transparent;\n  border: 0;\n}\n.dialog-overlay-loading:not(:required):after {\n  content: '';\n  display: block;\n  font-size: 10px;\n  width: 1em;\n  height: 1em;\n  margin-top: -0.5em;\n  -webkit-animation: spinner 1500ms infinite linear;\n  -moz-animation: spinner 1500ms infinite linear;\n  -ms-animation: spinner 1500ms infinite linear;\n  -o-animation: spinner 1500ms infinite linear;\n  animation: spinner 1500ms infinite linear;\n  border-radius: 0.5em;\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\n}\n\n/* Animation */\n@-webkit-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@-moz-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@-o-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA,6BAAA;AACA;EACA,gBAAA;EACA,aAAA;EACA,YAAA;EACA,WAAA;EACA,eAAA;EACA,aAAA;EACA,OAAA;EACA,QAAA;EACA,UAAA;EACA,SAAA;EACA,2CAAA;EACA,aAAA;CACA;;AAEA,yBAAA;AACA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,OAAA;EACA,QAAA;EACA,YAAA;EACA,aAAA;EACA,4EAAA;EACA,oFAAA;CACA;;AAEA,0DAAA;AACA;EACA,4BAAA;EACA,YAAA;EACA,mBAAA;EACA,kBAAA;EACA,8BAAA;EACA,UAAA;CACA;AAEA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,WAAA;EACA,YAAA;EACA,mBAAA;EACA,kDAAA;EACA,+CAAA;EACA,8CAAA;EACA,6CAAA;EACA,0CAAA;EACA,qBAAA;EACA,iVAAA;AACA,yUAAA;CACA;;AAEA,eAAA;AAEA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA","file":"DialogOverlay.vue","sourcesContent":["<template>\n  <transition name=\"opacity\">\n    <div class=\"dialog-overlay-loading\" :style=\"{zIndex: zIndex}\" v-if=\"visible\">Loading&#8230;</div>\n  </transition>\n</template>\n<script>\nexport default {\n  name: 'VDialogOverlay',\n  props: {\n    zIndex: {\n      type: Number,\n      default: () => 1250\n    },\n    visible: {\n      type: Boolean,\n      default: () => false\n    }\n  }\n}\n</script>\n<style>\n/* Absolute Center Spinner */\n.dialog-overlay-loading {\n  position: fixed;\n  z-index: 999;\n  height: 2em;\n  width: 2em;\n  overflow: show;\n  margin: auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  /* background: rgba(112, 112, 112, 0.4); */\n  cursor: wait;\n}\n\n/* Transparent Overlay */\n.dialog-overlay-loading:before {\n  content: '';\n  display: block;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n}\n\n/* :not(:required) hides these rules from IE9 and below */\n.dialog-overlay-loading:not(:required) {\n  /* hide \"loading...\" text */\n  font: 0/0 a;\n  color: transparent;\n  text-shadow: none;\n  background-color: transparent;\n  border: 0;\n}\n\n.dialog-overlay-loading:not(:required):after {\n  content: '';\n  display: block;\n  font-size: 10px;\n  width: 1em;\n  height: 1em;\n  margin-top: -0.5em;\n  -webkit-animation: spinner 1500ms infinite linear;\n  -moz-animation: spinner 1500ms infinite linear;\n  -ms-animation: spinner 1500ms infinite linear;\n  -o-animation: spinner 1500ms infinite linear;\n  animation: spinner 1500ms infinite linear;\n  border-radius: 0.5em;\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\n}\n\n/* Animation */\n\n@-webkit-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-moz-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-o-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n</style>\n"]}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = false;
  /* component normalizer */
  function __vue_normalize__$3(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    {
      var hook;
      if (style) {
        hook = function(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;
          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context)
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component
  }
  /* style inject */
  function __vue_create_injector__$3() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var DialogOverlay = __vue_normalize__$3(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    __vue_create_injector__$3,
    undefined
  )

var Confirmable = {
  name: 'Confirmable',
  props: {
    type: {
      type: String
    },
    text: {
      type: String,
      reqiured: true
    },
    title: {
      type: String
    },
    actions: {
      type: [Array, Object]
    }
  }
};

/* @vue/component */
var Returnable = {
  name: 'Returnable',
  props: {
    returnValue: null
  },

  data: function data() {
    return {
      originalValue: this.returnValue,
      returnResovers: []
    };
  },

  // watch: {
  //   'wrapper.isActive' (val) {
  //     console.log('watch.isActive', val)
  //     if (val) {
  //       this.originalValue = this.returnValue
  //     } else {
  //       // console.log('emit', this.originalValue)
  //       // this.$emit('submit', this.originalValue)
  //       this.$emit('update:returnValue', this.originalValue)
  //     }
  //   }
  // },
  methods: {
    return: function return$1(value) {
      this.originalValue = value;
      this.$root.$emit('submit', this.originalValue);
      this.$emit('submit', this.originalValue);
    }

  }
};

var Actionable = {
  name: 'Actionable',
  mixins: [Returnable],

  data: function data() {
    return {
      loadingAction: null
    };
  },

  props: {
    actions: {
      type: [Array, Object],
      default: function () { return []; }
    }
  },
  computed: {
    actionlist: function actionlist() {
      var this$1 = this;

      var actions = [];

      for (var key in this$1.actions) {
        var action = this$1.actions[key];

        if (typeof action === 'string') {
          action = {
            text: action
          };
        }

        this$1.$set(action, 'loading', false);

        if (!action.key) {
          action.key = isNaN(key) ? key : action.text;
        }

        if (['true', 'false'].indexOf(action.key) >= 0) {
          action.key = JSON.parse(action.key);
        }

        actions.push(action);
      }

      return actions;
    }

  },
  methods: {
    trigger: function trigger(name) {
      var action = this.actionlist.find(function (action) { return action.key === name; });

      if (action && !this.isActionDisabled(action) && this.isActionVisible(action)) {
        this.onActionClick(action);
      }
    },

    setLoadingToInstance: function setLoadingToInstance(vm, value) {
      if (vm && vm.loading !== undefined) {
        vm.loading = value;
      }
    },

    setLoadingState: function setLoadingState(value) {
      this.$emit('loading', value);
      !value && (this.loadingAction = null);
      this.setLoadingToInstance(this.$root, value);
      this.setLoadingToInstance(this.$root._dialogInstance, value);
    },

    isActionDisabled: function isActionDisabled(action) {
      if (action.disabled === undefined) {
        return false;
      }

      if (typeof action.disabled === 'function') {
        return action.disabled();
      }

      return action.disabled;
    },

    isActionVisible: function isActionVisible(action) {
      if (action.visible === undefined) {
        return true;
      }

      if (typeof action.visible === 'function') {
        return action.visible();
      }

      return action.visible;
    },

    onActionClick: function onActionClick(action) {
      return new Promise(function ($return, $error) {
        var closable;
        closable = action.closable === undefined || action.closable === true;

        if (action.handle) {
          this.loadingAction = action.key;
          this.setLoadingState(true);

          var $Try_1_Post = function () {
            try {
              return $If_2.call(this);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this);

          var $Try_1_Catch = function (e) {
            try {
              this.setLoadingState(false);
              console.log('error', e); // TODO

              throw e;
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this);

          try {
            var ret;
            return Promise.resolve(action.handle()).then(function ($await_3) {
              try {
                ret = $await_3;
                this.setLoadingState(false);

                if (ret !== false && closable) {
                  this.return(ret || action.key);
                }

                return $Try_1_Post();
              } catch ($boundEx) {
                return $Try_1_Catch($boundEx);
              }
            }.bind(this), $Try_1_Catch);
          } catch (e) {
            $Try_1_Catch(e);
          }
        } else {
          closable && this.return(action.key);
          return $If_2.call(this);
        }

        function $If_2() {
          return $return();
        }
      }.bind(this));
    }

  }
};

//
var script$4 = {
  mixins: [Actionable]
};

/* script */
            var __vue_script__$4 = script$4;
            
/* template */
var __vue_render__$4 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "span",
    _vm._l(_vm.actionlist, function(action) {
      return _c(
        "button",
        {
          key: action.key,
          staticClass: "button",
          class: { loading: _vm.loadingAction === action.key },
          attrs: {
            "action-key": "" + action.key,
            disabled: _vm.isActionDisabled(action) || !!_vm.loadingAction
          },
          on: {
            click: function($event) {
              _vm.onActionClick(action);
            }
          }
        },
        [_vm._v("\n    " + _vm._s(action.text) + "\n  ")]
      )
    })
  )
};
var __vue_staticRenderFns__$4 = [];
__vue_render__$4._withStripped = true;

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = false;
  /* component normalizer */
  function __vue_normalize__$4(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogActions.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    

    return component
  }
  /* style inject */
  function __vue_create_injector__$4() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var DialogActions = __vue_normalize__$4(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    __vue_create_injector__$4,
    undefined
  )

//
var script$5 = {
  components: {
    DialogActions: DialogActions
  },
  layout: 'default',
  mixins: [Confirmable]
};

/* script */
            var __vue_script__$5 = script$5;
            
/* template */
var __vue_render__$5 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "confirm-box" }, [
    !!_vm.title
      ? _c("div", { staticClass: "confirm-title" }, [
          _c("h1", { staticClass: "title" }, [_vm._v(_vm._s(_vm.title))])
        ])
      : _vm._e(),
    _vm._v(" "),
    _c("div", {
      staticClass: "confirm-message",
      domProps: { innerHTML: _vm._s(_vm.message) }
    }),
    _vm._v(" "),
    _c("div", { staticClass: "confirm-buttons" }, [
      _c(
        "div",
        { staticClass: "column" },
        [_c("DialogActions", { attrs: { actions: _vm.actions } })],
        1
      )
    ])
  ])
};
var __vue_staticRenderFns__$5 = [];
__vue_render__$5._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = function (inject) {
    if (!inject) { return }
    inject("data-v-8a87651c_0", { source: "\n.confirm-box {\n  background: #ffffff;\n}\n.confirm-box .confirm-title {\n  padding: 20px\n}\n.confirm-box .confirm-message {\n  padding: 0 20px;\n}\n.confirm-box .confirm-buttons {\n  text-align:  right;\n  padding: 10px 20px;\n}\n.confirm-box .confirm-buttons .button {\n  font-size: 20px;\n  padding-left: 20px;\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue"],"names":[],"mappings":";AA6BA;EACA,oBAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,mBAAA;EACA,mBAAA;CACA;AACA;EACA,gBAAA;EACA,mBAAA;CACA","file":"Confirm.vue","sourcesContent":["<template>\n  <div class=\"confirm-box\">\n    <div v-if=\"!!title\" class=\"confirm-title\">\n      <h1 class=\"title\">{{ title }}</h1>\n    </div>\n    <div class=\"confirm-message\" v-html=\"message\" />\n    <div class=\"confirm-buttons\">\n      <div class=\"column\">\n        <DialogActions :actions=\"actions\"/>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\n\nimport Confirmable from '../mixins/confirmable'\nimport DialogActions from './DialogActions.vue'\n\nexport default {\n  components: {\n    DialogActions\n  },\n  layout: 'default',\n  mixins: [ Confirmable ]\n}\n\n</script>\n\n<style>\n  .confirm-box {\n    background: #ffffff;\n  }\n  .confirm-box .confirm-title {\n    padding: 20px\n  }\n  .confirm-box .confirm-message {\n    padding: 0 20px;\n  }\n  .confirm-box .confirm-buttons {\n    text-align:  right;\n    padding: 10px 20px;\n  }\n  .confirm-box .confirm-buttons .button {\n    font-size: 20px;\n    padding-left: 20px;\n  }\n</style>\n"]}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* component normalizer */
  function __vue_normalize__$5(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    {
      var hook;
      if (style) {
        hook = function(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;
          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context)
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component
  }
  /* style inject */
  function __vue_create_injector__$5() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
    var isOldIE =
      typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;

        style.ids.push(id);

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';

          if (css.media) { el.setAttribute('media', css.media); }
          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts
            .filter(Boolean)
            .join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) { style.element.removeChild(nodes[index]); }
          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
          else { style.element.appendChild(textNode); }
        }
      }
    }
  }
  /* style inject SSR */
  

  
  var Confirm = __vue_normalize__$5(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    __vue_create_injector__$5,
    undefined
  )

/*
 * vuedl
 *
 * (c) Savaryn Yaroslav <yariksav@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var Plugin = {
  install: function install(Vue$$1, options) {
    if ( options === void 0 ) options = {};

    var property = options.property || '$dialog';
    var manager = new DialogManager(options); // const no = new Notificator(manager)

    Object.defineProperty(Vue$$1.prototype, property, {
      get: function get() {
        return manager;
      }

    });
    manager.layout('default', DialogLayout);
    manager.layout('notification', NotificationLayout);
    manager.overlay('default', DialogOverlay);
    manager.component('confirm', Confirm, {
      waitForResult: true,
      actions: {
        'false': 'Cancel',
        'true': 'OK'
      }
    });
    manager.component('warning', Confirm, {
      type: 'warning',
      waitForResult: true,
      actions: {
        'false': 'Cancel',
        'true': 'OK'
      }
    });
    manager.component('error', Confirm, {
      type: 'error',
      waitForResult: true,
      actions: ['OK']
    });
  }

};

module.exports = Plugin;
