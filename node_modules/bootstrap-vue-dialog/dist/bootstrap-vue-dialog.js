(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
	typeof define === 'function' && define.amd ? define(['vue'], factory) :
	(global.bootstrapVueDialog = factory(global.Vue));
}(this, (function (vue) { 'use strict';

	vue = vue && vue.hasOwnProperty('default') ? vue['default'] : vue;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var vuedl = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory(vue);
	}(commonjsGlobal, (function (Vue) {
	  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

	  var Recordable = {
	    computed: {
	      $parameters: function $parameters() {
	        return this.$options.propsData;
	      },

	      isNewRecord: function () {
	        return !this.$options.primaryKey || !this.$options.propsData || !this.$options.propsData[this.$options.primaryKey];
	      }
	    }
	  };

	  var Activable = {
	    name: 'Activable',

	    data: function data() {
	      return {
	        isActive: false
	      };
	    },

	    watch: {
	      isActive: function isActive(val) {
	        // debugger
	        // if (this.isLayout) {
	        // this.$children.forEach(vm => {
	        //   if (vm.isActive !== undefined) {
	        //     vm.isActive = val
	        //   }
	        // })
	        if (this._dialogInstance) {
	          if (this._dialogInstance.isActive !== undefined) {
	            this._dialogInstance.isActive = val;
	          }
	        } else {
	          if (this.$parent && this.$parent.isActive !== undefined) {
	            this.$parent.isActive = val;
	          }
	        }
	      }

	    },
	    methods: {
	      close: function close() {
	        this.isActive = false;
	      }

	    }
	  };

	  var Layoutable = {
	    name: 'Layoutable',
	    mixins: [Activable],
	    props: {
	      width: {
	        type: Number,
	        default: function () { return 450; }
	      },
	      persistent: Boolean
	    },

	    data: function data() {
	      return {
	        loading: false
	      };
	    },

	    compouted: {
	      isLayout: function isLayout() {
	        return true;
	      }

	    },
	    watch: {
	      isActive: function isActive(val) {
	        if (!val) {
	          // window.removeEventListener('popstate', this.close)
	          this._destroy();
	        }
	      }

	    },

	    mounted: function mounted() {
	      // this.$nextTick(() => {
	      // window.addEventListener('popstate', this.close)
	      // })
	      this.isActive = true;
	    },

	    methods: {
	      _destroy: function _destroy() {
	        this.$destroy();
	      },

	      dismiss: function dismiss() {
	        if (!this.persistent && !this.loading) {
	          this.isActive = false;
	        }
	      },

	      close: function close() {
	        this.isActive = false;
	      }

	    },

	    beforeDestroy: function beforeDestroy() {
	      if (typeof this.$el.remove !== 'undefined') {
	        this.$el.remove();
	      } else {
	        this.$el.parentNode.removeChild(this.$el);
	      }
	    }

	  };

	  /**
	   * Removes all key-value entries from the list cache.
	   *
	   * @private
	   * @name clear
	   * @memberOf ListCache
	   */
	  function listCacheClear() {
	    this.__data__ = [];
	    this.size = 0;
	  }

	  var _listCacheClear = listCacheClear;

	  /**
	   * Performs a
	   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	   * comparison between two values to determine if they are equivalent.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	   * @example
	   *
	   * var object = { 'a': 1 };
	   * var other = { 'a': 1 };
	   *
	   * _.eq(object, object);
	   * // => true
	   *
	   * _.eq(object, other);
	   * // => false
	   *
	   * _.eq('a', 'a');
	   * // => true
	   *
	   * _.eq('a', Object('a'));
	   * // => false
	   *
	   * _.eq(NaN, NaN);
	   * // => true
	   */
	  function eq(value, other) {
	    return value === other || (value !== value && other !== other);
	  }

	  var eq_1 = eq;

	  /**
	   * Gets the index at which the `key` is found in `array` of key-value pairs.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} key The key to search for.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function assocIndexOf(array, key) {
	    var length = array.length;
	    while (length--) {
	      if (eq_1(array[length][0], key)) {
	        return length;
	      }
	    }
	    return -1;
	  }

	  var _assocIndexOf = assocIndexOf;

	  /** Used for built-in method references. */
	  var arrayProto = Array.prototype;

	  /** Built-in value references. */
	  var splice = arrayProto.splice;

	  /**
	   * Removes `key` and its value from the list cache.
	   *
	   * @private
	   * @name delete
	   * @memberOf ListCache
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */
	  function listCacheDelete(key) {
	    var data = this.__data__,
	        index = _assocIndexOf(data, key);

	    if (index < 0) {
	      return false;
	    }
	    var lastIndex = data.length - 1;
	    if (index == lastIndex) {
	      data.pop();
	    } else {
	      splice.call(data, index, 1);
	    }
	    --this.size;
	    return true;
	  }

	  var _listCacheDelete = listCacheDelete;

	  /**
	   * Gets the list cache value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf ListCache
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */
	  function listCacheGet(key) {
	    var data = this.__data__,
	        index = _assocIndexOf(data, key);

	    return index < 0 ? undefined : data[index][1];
	  }

	  var _listCacheGet = listCacheGet;

	  /**
	   * Checks if a list cache value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf ListCache
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function listCacheHas(key) {
	    return _assocIndexOf(this.__data__, key) > -1;
	  }

	  var _listCacheHas = listCacheHas;

	  /**
	   * Sets the list cache `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf ListCache
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the list cache instance.
	   */
	  function listCacheSet(key, value) {
	    var data = this.__data__,
	        index = _assocIndexOf(data, key);

	    if (index < 0) {
	      ++this.size;
	      data.push([key, value]);
	    } else {
	      data[index][1] = value;
	    }
	    return this;
	  }

	  var _listCacheSet = listCacheSet;

	  /**
	   * Creates an list cache object.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */
	  function ListCache(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;

	    this.clear();
	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }

	  // Add methods to `ListCache`.
	  ListCache.prototype.clear = _listCacheClear;
	  ListCache.prototype['delete'] = _listCacheDelete;
	  ListCache.prototype.get = _listCacheGet;
	  ListCache.prototype.has = _listCacheHas;
	  ListCache.prototype.set = _listCacheSet;

	  var _ListCache = ListCache;

	  /**
	   * Removes all key-value entries from the stack.
	   *
	   * @private
	   * @name clear
	   * @memberOf Stack
	   */
	  function stackClear() {
	    this.__data__ = new _ListCache;
	    this.size = 0;
	  }

	  var _stackClear = stackClear;

	  /**
	   * Removes `key` and its value from the stack.
	   *
	   * @private
	   * @name delete
	   * @memberOf Stack
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */
	  function stackDelete(key) {
	    var data = this.__data__,
	        result = data['delete'](key);

	    this.size = data.size;
	    return result;
	  }

	  var _stackDelete = stackDelete;

	  /**
	   * Gets the stack value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf Stack
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */
	  function stackGet(key) {
	    return this.__data__.get(key);
	  }

	  var _stackGet = stackGet;

	  /**
	   * Checks if a stack value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf Stack
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function stackHas(key) {
	    return this.__data__.has(key);
	  }

	  var _stackHas = stackHas;

	  var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	  function createCommonjsModule$$1(fn, module) {
	  	return module = { exports: {} }, fn(module, module.exports), module.exports;
	  }

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof commonjsGlobal$$1 == 'object' && commonjsGlobal$$1 && commonjsGlobal$$1.Object === Object && commonjsGlobal$$1;

	  var _freeGlobal = freeGlobal;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = _freeGlobal || freeSelf || Function('return this')();

	  var _root = root;

	  /** Built-in value references. */
	  var Symbol = _root.Symbol;

	  var _Symbol = Symbol;

	  /** Used for built-in method references. */
	  var objectProto = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty = objectProto.hasOwnProperty;

	  /**
	   * Used to resolve the
	   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	   * of values.
	   */
	  var nativeObjectToString = objectProto.toString;

	  /** Built-in value references. */
	  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	  /**
	   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @returns {string} Returns the raw `toStringTag`.
	   */
	  function getRawTag(value) {
	    var isOwn = hasOwnProperty.call(value, symToStringTag),
	        tag = value[symToStringTag];

	    try {
	      value[symToStringTag] = undefined;
	      var unmasked = true;
	    } catch (e) {}

	    var result = nativeObjectToString.call(value);
	    if (unmasked) {
	      if (isOwn) {
	        value[symToStringTag] = tag;
	      } else {
	        delete value[symToStringTag];
	      }
	    }
	    return result;
	  }

	  var _getRawTag = getRawTag;

	  /** Used for built-in method references. */
	  var objectProto$1 = Object.prototype;

	  /**
	   * Used to resolve the
	   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	   * of values.
	   */
	  var nativeObjectToString$1 = objectProto$1.toString;

	  /**
	   * Converts `value` to a string using `Object.prototype.toString`.
	   *
	   * @private
	   * @param {*} value The value to convert.
	   * @returns {string} Returns the converted string.
	   */
	  function objectToString(value) {
	    return nativeObjectToString$1.call(value);
	  }

	  var _objectToString = objectToString;

	  /** `Object#toString` result references. */
	  var nullTag = '[object Null]',
	      undefinedTag = '[object Undefined]';

	  /** Built-in value references. */
	  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	  /**
	   * The base implementation of `getTag` without fallbacks for buggy environments.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @returns {string} Returns the `toStringTag`.
	   */
	  function baseGetTag(value) {
	    if (value == null) {
	      return value === undefined ? undefinedTag : nullTag;
	    }
	    return (symToStringTag$1 && symToStringTag$1 in Object(value))
	      ? _getRawTag(value)
	      : _objectToString(value);
	  }

	  var _baseGetTag = baseGetTag;

	  /**
	   * Checks if `value` is the
	   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	   * @example
	   *
	   * _.isObject({});
	   * // => true
	   *
	   * _.isObject([1, 2, 3]);
	   * // => true
	   *
	   * _.isObject(_.noop);
	   * // => true
	   *
	   * _.isObject(null);
	   * // => false
	   */
	  function isObject(value) {
	    var type = typeof value;
	    return value != null && (type == 'object' || type == 'function');
	  }

	  var isObject_1 = isObject;

	  /** `Object#toString` result references. */
	  var asyncTag = '[object AsyncFunction]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      proxyTag = '[object Proxy]';

	  /**
	   * Checks if `value` is classified as a `Function` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	   * @example
	   *
	   * _.isFunction(_);
	   * // => true
	   *
	   * _.isFunction(/abc/);
	   * // => false
	   */
	  function isFunction(value) {
	    if (!isObject_1(value)) {
	      return false;
	    }
	    // The use of `Object#toString` avoids issues with the `typeof` operator
	    // in Safari 9 which returns 'object' for typed arrays and other constructors.
	    var tag = _baseGetTag(value);
	    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	  }

	  var isFunction_1 = isFunction;

	  /** Used to detect overreaching core-js shims. */
	  var coreJsData = _root['__core-js_shared__'];

	  var _coreJsData = coreJsData;

	  /** Used to detect methods masquerading as native. */
	  var maskSrcKey = (function() {
	    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	    return uid ? ('Symbol(src)_1.' + uid) : '';
	  }());

	  /**
	   * Checks if `func` has its source masked.
	   *
	   * @private
	   * @param {Function} func The function to check.
	   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	   */
	  function isMasked(func) {
	    return !!maskSrcKey && (maskSrcKey in func);
	  }

	  var _isMasked = isMasked;

	  /** Used for built-in method references. */
	  var funcProto = Function.prototype;

	  /** Used to resolve the decompiled source of functions. */
	  var funcToString = funcProto.toString;

	  /**
	   * Converts `func` to its source code.
	   *
	   * @private
	   * @param {Function} func The function to convert.
	   * @returns {string} Returns the source code.
	   */
	  function toSource(func) {
	    if (func != null) {
	      try {
	        return funcToString.call(func);
	      } catch (e) {}
	      try {
	        return (func + '');
	      } catch (e) {}
	    }
	    return '';
	  }

	  var _toSource = toSource;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used for built-in method references. */
	  var funcProto$1 = Function.prototype,
	      objectProto$2 = Object.prototype;

	  /** Used to resolve the decompiled source of functions. */
	  var funcToString$1 = funcProto$1.toString;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	  /** Used to detect if a method is native. */
	  var reIsNative = RegExp('^' +
	    funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	  );

	  /**
	   * The base implementation of `_.isNative` without bad shim checks.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a native function,
	   *  else `false`.
	   */
	  function baseIsNative(value) {
	    if (!isObject_1(value) || _isMasked(value)) {
	      return false;
	    }
	    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	    return pattern.test(_toSource(value));
	  }

	  var _baseIsNative = baseIsNative;

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }

	  var _getValue = getValue;

	  /**
	   * Gets the native function at `key` of `object`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {string} key The key of the method to get.
	   * @returns {*} Returns the function if it's native, else `undefined`.
	   */
	  function getNative(object, key) {
	    var value = _getValue(object, key);
	    return _baseIsNative(value) ? value : undefined;
	  }

	  var _getNative = getNative;

	  /* Built-in method references that are verified to be native. */
	  var Map = _getNative(_root, 'Map');

	  var _Map = Map;

	  /* Built-in method references that are verified to be native. */
	  var nativeCreate = _getNative(Object, 'create');

	  var _nativeCreate = nativeCreate;

	  /**
	   * Removes all key-value entries from the hash.
	   *
	   * @private
	   * @name clear
	   * @memberOf Hash
	   */
	  function hashClear() {
	    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	    this.size = 0;
	  }

	  var _hashClear = hashClear;

	  /**
	   * Removes `key` and its value from the hash.
	   *
	   * @private
	   * @name delete
	   * @memberOf Hash
	   * @param {Object} hash The hash to modify.
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */
	  function hashDelete(key) {
	    var result = this.has(key) && delete this.__data__[key];
	    this.size -= result ? 1 : 0;
	    return result;
	  }

	  var _hashDelete = hashDelete;

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used for built-in method references. */
	  var objectProto$3 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	  /**
	   * Gets the hash value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf Hash
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */
	  function hashGet(key) {
	    var data = this.__data__;
	    if (_nativeCreate) {
	      var result = data[key];
	      return result === HASH_UNDEFINED ? undefined : result;
	    }
	    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	  }

	  var _hashGet = hashGet;

	  /** Used for built-in method references. */
	  var objectProto$4 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	  /**
	   * Checks if a hash value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf Hash
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function hashHas(key) {
	    var data = this.__data__;
	    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	  }

	  var _hashHas = hashHas;

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	  /**
	   * Sets the hash `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf Hash
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the hash instance.
	   */
	  function hashSet(key, value) {
	    var data = this.__data__;
	    this.size += this.has(key) ? 0 : 1;
	    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	    return this;
	  }

	  var _hashSet = hashSet;

	  /**
	   * Creates a hash object.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */
	  function Hash(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;

	    this.clear();
	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }

	  // Add methods to `Hash`.
	  Hash.prototype.clear = _hashClear;
	  Hash.prototype['delete'] = _hashDelete;
	  Hash.prototype.get = _hashGet;
	  Hash.prototype.has = _hashHas;
	  Hash.prototype.set = _hashSet;

	  var _Hash = Hash;

	  /**
	   * Removes all key-value entries from the map.
	   *
	   * @private
	   * @name clear
	   * @memberOf MapCache
	   */
	  function mapCacheClear() {
	    this.size = 0;
	    this.__data__ = {
	      'hash': new _Hash,
	      'map': new (_Map || _ListCache),
	      'string': new _Hash
	    };
	  }

	  var _mapCacheClear = mapCacheClear;

	  /**
	   * Checks if `value` is suitable for use as unique object key.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	   */
	  function isKeyable(value) {
	    var type = typeof value;
	    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	      ? (value !== '__proto__')
	      : (value === null);
	  }

	  var _isKeyable = isKeyable;

	  /**
	   * Gets the data for `map`.
	   *
	   * @private
	   * @param {Object} map The map to query.
	   * @param {string} key The reference key.
	   * @returns {*} Returns the map data.
	   */
	  function getMapData(map, key) {
	    var data = map.__data__;
	    return _isKeyable(key)
	      ? data[typeof key == 'string' ? 'string' : 'hash']
	      : data.map;
	  }

	  var _getMapData = getMapData;

	  /**
	   * Removes `key` and its value from the map.
	   *
	   * @private
	   * @name delete
	   * @memberOf MapCache
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */
	  function mapCacheDelete(key) {
	    var result = _getMapData(this, key)['delete'](key);
	    this.size -= result ? 1 : 0;
	    return result;
	  }

	  var _mapCacheDelete = mapCacheDelete;

	  /**
	   * Gets the map value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf MapCache
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */
	  function mapCacheGet(key) {
	    return _getMapData(this, key).get(key);
	  }

	  var _mapCacheGet = mapCacheGet;

	  /**
	   * Checks if a map value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf MapCache
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function mapCacheHas(key) {
	    return _getMapData(this, key).has(key);
	  }

	  var _mapCacheHas = mapCacheHas;

	  /**
	   * Sets the map `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf MapCache
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the map cache instance.
	   */
	  function mapCacheSet(key, value) {
	    var data = _getMapData(this, key),
	        size = data.size;

	    data.set(key, value);
	    this.size += data.size == size ? 0 : 1;
	    return this;
	  }

	  var _mapCacheSet = mapCacheSet;

	  /**
	   * Creates a map cache object to store key-value pairs.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */
	  function MapCache(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;

	    this.clear();
	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }

	  // Add methods to `MapCache`.
	  MapCache.prototype.clear = _mapCacheClear;
	  MapCache.prototype['delete'] = _mapCacheDelete;
	  MapCache.prototype.get = _mapCacheGet;
	  MapCache.prototype.has = _mapCacheHas;
	  MapCache.prototype.set = _mapCacheSet;

	  var _MapCache = MapCache;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /**
	   * Sets the stack `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf Stack
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the stack cache instance.
	   */
	  function stackSet(key, value) {
	    var data = this.__data__;
	    if (data instanceof _ListCache) {
	      var pairs = data.__data__;
	      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	        pairs.push([key, value]);
	        this.size = ++data.size;
	        return this;
	      }
	      data = this.__data__ = new _MapCache(pairs);
	    }
	    data.set(key, value);
	    this.size = data.size;
	    return this;
	  }

	  var _stackSet = stackSet;

	  /**
	   * Creates a stack cache object to store key-value pairs.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */
	  function Stack(entries) {
	    var data = this.__data__ = new _ListCache(entries);
	    this.size = data.size;
	  }

	  // Add methods to `Stack`.
	  Stack.prototype.clear = _stackClear;
	  Stack.prototype['delete'] = _stackDelete;
	  Stack.prototype.get = _stackGet;
	  Stack.prototype.has = _stackHas;
	  Stack.prototype.set = _stackSet;

	  var _Stack = Stack;

	  var defineProperty = (function() {
	    try {
	      var func = _getNative(Object, 'defineProperty');
	      func({}, '', {});
	      return func;
	    } catch (e) {}
	  }());

	  var _defineProperty = defineProperty;

	  /**
	   * The base implementation of `assignValue` and `assignMergeValue` without
	   * value checks.
	   *
	   * @private
	   * @param {Object} object The object to modify.
	   * @param {string} key The key of the property to assign.
	   * @param {*} value The value to assign.
	   */
	  function baseAssignValue(object, key, value) {
	    if (key == '__proto__' && _defineProperty) {
	      _defineProperty(object, key, {
	        'configurable': true,
	        'enumerable': true,
	        'value': value,
	        'writable': true
	      });
	    } else {
	      object[key] = value;
	    }
	  }

	  var _baseAssignValue = baseAssignValue;

	  /**
	   * This function is like `assignValue` except that it doesn't assign
	   * `undefined` values.
	   *
	   * @private
	   * @param {Object} object The object to modify.
	   * @param {string} key The key of the property to assign.
	   * @param {*} value The value to assign.
	   */
	  function assignMergeValue(object, key, value) {
	    if ((value !== undefined && !eq_1(object[key], value)) ||
	        (value === undefined && !(key in object))) {
	      _baseAssignValue(object, key, value);
	    }
	  }

	  var _assignMergeValue = assignMergeValue;

	  /**
	   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	   *
	   * @private
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {Function} Returns the new base function.
	   */
	  function createBaseFor(fromRight) {
	    return function(object, iteratee, keysFunc) {
	      var index = -1,
	          iterable = Object(object),
	          props = keysFunc(object),
	          length = props.length;

	      while (length--) {
	        var key = props[fromRight ? length : ++index];
	        if (iteratee(iterable[key], key, iterable) === false) {
	          break;
	        }
	      }
	      return object;
	    };
	  }

	  var _createBaseFor = createBaseFor;

	  /**
	   * The base implementation of `baseForOwn` which iterates over `object`
	   * properties returned by `keysFunc` and invokes `iteratee` for each property.
	   * Iteratee functions may exit iteration early by explicitly returning `false`.
	   *
	   * @private
	   * @param {Object} object The object to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {Function} keysFunc The function to get the keys of `object`.
	   * @returns {Object} Returns `object`.
	   */
	  var baseFor = _createBaseFor();

	  var _baseFor = baseFor;

	  var _cloneBuffer = createCommonjsModule$$1(function (module, exports) {
	  /** Detect free variable `exports`. */
	  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Built-in value references. */
	  var Buffer = moduleExports ? _root.Buffer : undefined,
	      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	  /**
	   * Creates a clone of  `buffer`.
	   *
	   * @private
	   * @param {Buffer} buffer The buffer to clone.
	   * @param {boolean} [isDeep] Specify a deep clone.
	   * @returns {Buffer} Returns the cloned buffer.
	   */
	  function cloneBuffer(buffer, isDeep) {
	    if (isDeep) {
	      return buffer.slice();
	    }
	    var length = buffer.length,
	        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	    buffer.copy(result);
	    return result;
	  }

	  module.exports = cloneBuffer;
	  });

	  /** Built-in value references. */
	  var Uint8Array = _root.Uint8Array;

	  var _Uint8Array = Uint8Array;

	  /**
	   * Creates a clone of `arrayBuffer`.
	   *
	   * @private
	   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	   * @returns {ArrayBuffer} Returns the cloned array buffer.
	   */
	  function cloneArrayBuffer(arrayBuffer) {
	    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	    return result;
	  }

	  var _cloneArrayBuffer = cloneArrayBuffer;

	  /**
	   * Creates a clone of `typedArray`.
	   *
	   * @private
	   * @param {Object} typedArray The typed array to clone.
	   * @param {boolean} [isDeep] Specify a deep clone.
	   * @returns {Object} Returns the cloned typed array.
	   */
	  function cloneTypedArray(typedArray, isDeep) {
	    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	  }

	  var _cloneTypedArray = cloneTypedArray;

	  /**
	   * Copies the values of `source` to `array`.
	   *
	   * @private
	   * @param {Array} source The array to copy values from.
	   * @param {Array} [array=[]] The array to copy values to.
	   * @returns {Array} Returns `array`.
	   */
	  function copyArray(source, array) {
	    var index = -1,
	        length = source.length;

	    array || (array = Array(length));
	    while (++index < length) {
	      array[index] = source[index];
	    }
	    return array;
	  }

	  var _copyArray = copyArray;

	  /** Built-in value references. */
	  var objectCreate = Object.create;

	  /**
	   * The base implementation of `_.create` without support for assigning
	   * properties to the created object.
	   *
	   * @private
	   * @param {Object} proto The object to inherit from.
	   * @returns {Object} Returns the new object.
	   */
	  var baseCreate = (function() {
	    function object() {}
	    return function(proto) {
	      if (!isObject_1(proto)) {
	        return {};
	      }
	      if (objectCreate) {
	        return objectCreate(proto);
	      }
	      object.prototype = proto;
	      var result = new object;
	      object.prototype = undefined;
	      return result;
	    };
	  }());

	  var _baseCreate = baseCreate;

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  var _overArg = overArg;

	  /** Built-in value references. */
	  var getPrototype = _overArg(Object.getPrototypeOf, Object);

	  var _getPrototype = getPrototype;

	  /** Used for built-in method references. */
	  var objectProto$5 = Object.prototype;

	  /**
	   * Checks if `value` is likely a prototype object.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	   */
	  function isPrototype(value) {
	    var Ctor = value && value.constructor,
	        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

	    return value === proto;
	  }

	  var _isPrototype = isPrototype;

	  /**
	   * Initializes an object clone.
	   *
	   * @private
	   * @param {Object} object The object to clone.
	   * @returns {Object} Returns the initialized clone.
	   */
	  function initCloneObject(object) {
	    return (typeof object.constructor == 'function' && !_isPrototype(object))
	      ? _baseCreate(_getPrototype(object))
	      : {};
	  }

	  var _initCloneObject = initCloneObject;

	  /**
	   * Checks if `value` is object-like. A value is object-like if it's not `null`
	   * and has a `typeof` result of "object".
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   * @example
	   *
	   * _.isObjectLike({});
	   * // => true
	   *
	   * _.isObjectLike([1, 2, 3]);
	   * // => true
	   *
	   * _.isObjectLike(_.noop);
	   * // => false
	   *
	   * _.isObjectLike(null);
	   * // => false
	   */
	  function isObjectLike(value) {
	    return value != null && typeof value == 'object';
	  }

	  var isObjectLike_1 = isObjectLike;

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]';

	  /**
	   * The base implementation of `_.isArguments`.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	   */
	  function baseIsArguments(value) {
	    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	  }

	  var _baseIsArguments = baseIsArguments;

	  /** Used for built-in method references. */
	  var objectProto$6 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

	  /** Built-in value references. */
	  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	  /**
	   * Checks if `value` is likely an `arguments` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	   *  else `false`.
	   * @example
	   *
	   * _.isArguments(function() { return arguments; }());
	   * // => true
	   *
	   * _.isArguments([1, 2, 3]);
	   * // => false
	   */
	  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	    return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&
	      !propertyIsEnumerable.call(value, 'callee');
	  };

	  var isArguments_1 = isArguments;

	  /**
	   * Checks if `value` is classified as an `Array` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	   * @example
	   *
	   * _.isArray([1, 2, 3]);
	   * // => true
	   *
	   * _.isArray(document.body.children);
	   * // => false
	   *
	   * _.isArray('abc');
	   * // => false
	   *
	   * _.isArray(_.noop);
	   * // => false
	   */
	  var isArray = Array.isArray;

	  var isArray_1 = isArray;

	  /** Used as references for various `Number` constants. */
	  var MAX_SAFE_INTEGER = 9007199254740991;

	  /**
	   * Checks if `value` is a valid array-like length.
	   *
	   * **Note:** This method is loosely based on
	   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	   * @example
	   *
	   * _.isLength(3);
	   * // => true
	   *
	   * _.isLength(Number.MIN_VALUE);
	   * // => false
	   *
	   * _.isLength(Infinity);
	   * // => false
	   *
	   * _.isLength('3');
	   * // => false
	   */
	  function isLength(value) {
	    return typeof value == 'number' &&
	      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	  }

	  var isLength_1 = isLength;

	  /**
	   * Checks if `value` is array-like. A value is considered array-like if it's
	   * not a function and has a `value.length` that's an integer greater than or
	   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	   * @example
	   *
	   * _.isArrayLike([1, 2, 3]);
	   * // => true
	   *
	   * _.isArrayLike(document.body.children);
	   * // => true
	   *
	   * _.isArrayLike('abc');
	   * // => true
	   *
	   * _.isArrayLike(_.noop);
	   * // => false
	   */
	  function isArrayLike(value) {
	    return value != null && isLength_1(value.length) && !isFunction_1(value);
	  }

	  var isArrayLike_1 = isArrayLike;

	  /**
	   * This method is like `_.isArrayLike` except that it also checks if `value`
	   * is an object.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an array-like object,
	   *  else `false`.
	   * @example
	   *
	   * _.isArrayLikeObject([1, 2, 3]);
	   * // => true
	   *
	   * _.isArrayLikeObject(document.body.children);
	   * // => true
	   *
	   * _.isArrayLikeObject('abc');
	   * // => false
	   *
	   * _.isArrayLikeObject(_.noop);
	   * // => false
	   */
	  function isArrayLikeObject(value) {
	    return isObjectLike_1(value) && isArrayLike_1(value);
	  }

	  var isArrayLikeObject_1 = isArrayLikeObject;

	  /**
	   * This method returns `false`.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.13.0
	   * @category Util
	   * @returns {boolean} Returns `false`.
	   * @example
	   *
	   * _.times(2, _.stubFalse);
	   * // => [false, false]
	   */
	  function stubFalse() {
	    return false;
	  }

	  var stubFalse_1 = stubFalse;

	  var isBuffer_1 = createCommonjsModule$$1(function (module, exports) {
	  /** Detect free variable `exports`. */
	  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Built-in value references. */
	  var Buffer = moduleExports ? _root.Buffer : undefined;

	  /* Built-in method references for those with the same name as other `lodash` methods. */
	  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	  /**
	   * Checks if `value` is a buffer.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.3.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	   * @example
	   *
	   * _.isBuffer(new Buffer(2));
	   * // => true
	   *
	   * _.isBuffer(new Uint8Array(2));
	   * // => false
	   */
	  var isBuffer = nativeIsBuffer || stubFalse_1;

	  module.exports = isBuffer;
	  });

	  /** `Object#toString` result references. */
	  var objectTag = '[object Object]';

	  /** Used for built-in method references. */
	  var funcProto$2 = Function.prototype,
	      objectProto$7 = Object.prototype;

	  /** Used to resolve the decompiled source of functions. */
	  var funcToString$2 = funcProto$2.toString;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

	  /** Used to infer the `Object` constructor. */
	  var objectCtorString = funcToString$2.call(Object);

	  /**
	   * Checks if `value` is a plain object, that is, an object created by the
	   * `Object` constructor or one with a `[[Prototype]]` of `null`.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.8.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	   * @example
	   *
	   * function Foo() {
	   *   this.a = 1;
	   * }
	   *
	   * _.isPlainObject(new Foo);
	   * // => false
	   *
	   * _.isPlainObject([1, 2, 3]);
	   * // => false
	   *
	   * _.isPlainObject({ 'x': 0, 'y': 0 });
	   * // => true
	   *
	   * _.isPlainObject(Object.create(null));
	   * // => true
	   */
	  function isPlainObject(value) {
	    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
	      return false;
	    }
	    var proto = _getPrototype(value);
	    if (proto === null) {
	      return true;
	    }
	    var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;
	    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	      funcToString$2.call(Ctor) == objectCtorString;
	  }

	  var isPlainObject_1 = isPlainObject;

	  /** `Object#toString` result references. */
	  var argsTag$1 = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag$1 = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag$1 = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /**
	   * The base implementation of `_.isTypedArray` without Node.js optimizations.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	   */
	  function baseIsTypedArray(value) {
	    return isObjectLike_1(value) &&
	      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	  }

	  var _baseIsTypedArray = baseIsTypedArray;

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  var _baseUnary = baseUnary;

	  var _nodeUtil = createCommonjsModule$$1(function (module, exports) {
	  /** Detect free variable `exports`. */
	  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && _freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  module.exports = nodeUtil;
	  });

	  /* Node.js helper references. */
	  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	  /**
	   * Checks if `value` is classified as a typed array.
	   *
	   * @static
	   * @memberOf _
	   * @since 3.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	   * @example
	   *
	   * _.isTypedArray(new Uint8Array);
	   * // => true
	   *
	   * _.isTypedArray([]);
	   * // => false
	   */
	  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	  var isTypedArray_1 = isTypedArray;

	  /**
	   * Gets the value at `key`, unless `key` is "__proto__".
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function safeGet(object, key) {
	    return key == '__proto__'
	      ? undefined
	      : object[key];
	  }

	  var _safeGet = safeGet;

	  /** Used for built-in method references. */
	  var objectProto$8 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	  /**
	   * Assigns `value` to `key` of `object` if the existing value is not equivalent
	   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	   * for equality comparisons.
	   *
	   * @private
	   * @param {Object} object The object to modify.
	   * @param {string} key The key of the property to assign.
	   * @param {*} value The value to assign.
	   */
	  function assignValue(object, key, value) {
	    var objValue = object[key];
	    if (!(hasOwnProperty$6.call(object, key) && eq_1(objValue, value)) ||
	        (value === undefined && !(key in object))) {
	      _baseAssignValue(object, key, value);
	    }
	  }

	  var _assignValue = assignValue;

	  /**
	   * Copies properties of `source` to `object`.
	   *
	   * @private
	   * @param {Object} source The object to copy properties from.
	   * @param {Array} props The property identifiers to copy.
	   * @param {Object} [object={}] The object to copy properties to.
	   * @param {Function} [customizer] The function to customize copied values.
	   * @returns {Object} Returns `object`.
	   */
	  function copyObject(source, props, object, customizer) {
	    var isNew = !object;
	    object || (object = {});

	    var index = -1,
	        length = props.length;

	    while (++index < length) {
	      var key = props[index];

	      var newValue = customizer
	        ? customizer(object[key], source[key], key, object, source)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = source[key];
	      }
	      if (isNew) {
	        _baseAssignValue(object, key, newValue);
	      } else {
	        _assignValue(object, key, newValue);
	      }
	    }
	    return object;
	  }

	  var _copyObject = copyObject;

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  var _baseTimes = baseTimes;

	  /** Used as references for various `Number` constants. */
	  var MAX_SAFE_INTEGER$1 = 9007199254740991;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /**
	   * Checks if `value` is a valid array-like index.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	   */
	  function isIndex(value, length) {
	    var type = typeof value;
	    length = length == null ? MAX_SAFE_INTEGER$1 : length;

	    return !!length &&
	      (type == 'number' ||
	        (type != 'symbol' && reIsUint.test(value))) &&
	          (value > -1 && value % 1 == 0 && value < length);
	  }

	  var _isIndex = isIndex;

	  /** Used for built-in method references. */
	  var objectProto$9 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	  /**
	   * Creates an array of the enumerable property names of the array-like `value`.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @param {boolean} inherited Specify returning inherited property names.
	   * @returns {Array} Returns the array of property names.
	   */
	  function arrayLikeKeys(value, inherited) {
	    var isArr = isArray_1(value),
	        isArg = !isArr && isArguments_1(value),
	        isBuff = !isArr && !isArg && isBuffer_1(value),
	        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	        skipIndexes = isArr || isArg || isBuff || isType,
	        result = skipIndexes ? _baseTimes(value.length, String) : [],
	        length = result.length;

	    for (var key in value) {
	      if ((inherited || hasOwnProperty$7.call(value, key)) &&
	          !(skipIndexes && (
	             // Safari 9 has enumerable `arguments.length` in strict mode.
	             key == 'length' ||
	             // Node.js 0.10 has enumerable non-index properties on buffers.
	             (isBuff && (key == 'offset' || key == 'parent')) ||
	             // PhantomJS 2 has enumerable non-index properties on typed arrays.
	             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	             // Skip index properties.
	             _isIndex(key, length)
	          ))) {
	        result.push(key);
	      }
	    }
	    return result;
	  }

	  var _arrayLikeKeys = arrayLikeKeys;

	  /**
	   * This function is like
	   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	   * except that it includes inherited enumerable properties.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names.
	   */
	  function nativeKeysIn(object) {
	    var result = [];
	    if (object != null) {
	      for (var key in Object(object)) {
	        result.push(key);
	      }
	    }
	    return result;
	  }

	  var _nativeKeysIn = nativeKeysIn;

	  /** Used for built-in method references. */
	  var objectProto$10 = Object.prototype;

	  /** Used to check objects for own properties. */
	  var hasOwnProperty$8 = objectProto$10.hasOwnProperty;

	  /**
	   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names.
	   */
	  function baseKeysIn(object) {
	    if (!isObject_1(object)) {
	      return _nativeKeysIn(object);
	    }
	    var isProto = _isPrototype(object),
	        result = [];

	    for (var key in object) {
	      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
	        result.push(key);
	      }
	    }
	    return result;
	  }

	  var _baseKeysIn = baseKeysIn;

	  /**
	   * Creates an array of the own and inherited enumerable property names of `object`.
	   *
	   * **Note:** Non-object values are coerced to objects.
	   *
	   * @static
	   * @memberOf _
	   * @since 3.0.0
	   * @category Object
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names.
	   * @example
	   *
	   * function Foo() {
	   *   this.a = 1;
	   *   this.b = 2;
	   * }
	   *
	   * Foo.prototype.c = 3;
	   *
	   * _.keysIn(new Foo);
	   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	   */
	  function keysIn(object) {
	    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	  }

	  var keysIn_1 = keysIn;

	  /**
	   * Converts `value` to a plain object flattening inherited enumerable string
	   * keyed properties of `value` to own properties of the plain object.
	   *
	   * @static
	   * @memberOf _
	   * @since 3.0.0
	   * @category Lang
	   * @param {*} value The value to convert.
	   * @returns {Object} Returns the converted plain object.
	   * @example
	   *
	   * function Foo() {
	   *   this.b = 2;
	   * }
	   *
	   * Foo.prototype.c = 3;
	   *
	   * _.assign({ 'a': 1 }, new Foo);
	   * // => { 'a': 1, 'b': 2 }
	   *
	   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	   * // => { 'a': 1, 'b': 2, 'c': 3 }
	   */
	  function toPlainObject(value) {
	    return _copyObject(value, keysIn_1(value));
	  }

	  var toPlainObject_1 = toPlainObject;

	  /**
	   * A specialized version of `baseMerge` for arrays and objects which performs
	   * deep merges and tracks traversed objects enabling objects with circular
	   * references to be merged.
	   *
	   * @private
	   * @param {Object} object The destination object.
	   * @param {Object} source The source object.
	   * @param {string} key The key of the value to merge.
	   * @param {number} srcIndex The index of `source`.
	   * @param {Function} mergeFunc The function to merge values.
	   * @param {Function} [customizer] The function to customize assigned values.
	   * @param {Object} [stack] Tracks traversed source values and their merged
	   *  counterparts.
	   */
	  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	    var objValue = _safeGet(object, key),
	        srcValue = _safeGet(source, key),
	        stacked = stack.get(srcValue);

	    if (stacked) {
	      _assignMergeValue(object, key, stacked);
	      return;
	    }
	    var newValue = customizer
	      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	      : undefined;

	    var isCommon = newValue === undefined;

	    if (isCommon) {
	      var isArr = isArray_1(srcValue),
	          isBuff = !isArr && isBuffer_1(srcValue),
	          isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

	      newValue = srcValue;
	      if (isArr || isBuff || isTyped) {
	        if (isArray_1(objValue)) {
	          newValue = objValue;
	        }
	        else if (isArrayLikeObject_1(objValue)) {
	          newValue = _copyArray(objValue);
	        }
	        else if (isBuff) {
	          isCommon = false;
	          newValue = _cloneBuffer(srcValue, true);
	        }
	        else if (isTyped) {
	          isCommon = false;
	          newValue = _cloneTypedArray(srcValue, true);
	        }
	        else {
	          newValue = [];
	        }
	      }
	      else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
	        newValue = objValue;
	        if (isArguments_1(objValue)) {
	          newValue = toPlainObject_1(objValue);
	        }
	        else if (!isObject_1(objValue) || (srcIndex && isFunction_1(objValue))) {
	          newValue = _initCloneObject(srcValue);
	        }
	      }
	      else {
	        isCommon = false;
	      }
	    }
	    if (isCommon) {
	      // Recursively merge objects and arrays (susceptible to call stack limits).
	      stack.set(srcValue, newValue);
	      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	      stack['delete'](srcValue);
	    }
	    _assignMergeValue(object, key, newValue);
	  }

	  var _baseMergeDeep = baseMergeDeep;

	  /**
	   * The base implementation of `_.merge` without support for multiple sources.
	   *
	   * @private
	   * @param {Object} object The destination object.
	   * @param {Object} source The source object.
	   * @param {number} srcIndex The index of `source`.
	   * @param {Function} [customizer] The function to customize merged values.
	   * @param {Object} [stack] Tracks traversed source values and their merged
	   *  counterparts.
	   */
	  function baseMerge(object, source, srcIndex, customizer, stack) {
	    if (object === source) {
	      return;
	    }
	    _baseFor(source, function(srcValue, key) {
	      if (isObject_1(srcValue)) {
	        stack || (stack = new _Stack);
	        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	      }
	      else {
	        var newValue = customizer
	          ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
	          : undefined;

	        if (newValue === undefined) {
	          newValue = srcValue;
	        }
	        _assignMergeValue(object, key, newValue);
	      }
	    }, keysIn_1);
	  }

	  var _baseMerge = baseMerge;

	  /**
	   * This method returns the first argument it receives.
	   *
	   * @static
	   * @since 0.1.0
	   * @memberOf _
	   * @category Util
	   * @param {*} value Any value.
	   * @returns {*} Returns `value`.
	   * @example
	   *
	   * var object = { 'a': 1 };
	   *
	   * console.log(_.identity(object) === object);
	   * // => true
	   */
	  function identity(value) {
	    return value;
	  }

	  var identity_1 = identity;

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  var _apply = apply;

	  /* Built-in method references for those with the same name as other `lodash` methods. */
	  var nativeMax = Math.max;

	  /**
	   * A specialized version of `baseRest` which transforms the rest array.
	   *
	   * @private
	   * @param {Function} func The function to apply a rest parameter to.
	   * @param {number} [start=func.length-1] The start position of the rest parameter.
	   * @param {Function} transform The rest array transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overRest(func, start, transform) {
	    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	    return function() {
	      var args = arguments,
	          index = -1,
	          length = nativeMax(args.length - start, 0),
	          array = Array(length);

	      while (++index < length) {
	        array[index] = args[start + index];
	      }
	      index = -1;
	      var otherArgs = Array(start + 1);
	      while (++index < start) {
	        otherArgs[index] = args[index];
	      }
	      otherArgs[start] = transform(array);
	      return _apply(func, this, otherArgs);
	    };
	  }

	  var _overRest = overRest;

	  /**
	   * Creates a function that returns `value`.
	   *
	   * @static
	   * @memberOf _
	   * @since 2.4.0
	   * @category Util
	   * @param {*} value The value to return from the new function.
	   * @returns {Function} Returns the new constant function.
	   * @example
	   *
	   * var objects = _.times(2, _.constant({ 'a': 1 }));
	   *
	   * console.log(objects);
	   * // => [{ 'a': 1 }, { 'a': 1 }]
	   *
	   * console.log(objects[0] === objects[1]);
	   * // => true
	   */
	  function constant(value) {
	    return function() {
	      return value;
	    };
	  }

	  var constant_1 = constant;

	  /**
	   * The base implementation of `setToString` without support for hot loop shorting.
	   *
	   * @private
	   * @param {Function} func The function to modify.
	   * @param {Function} string The `toString` result.
	   * @returns {Function} Returns `func`.
	   */
	  var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
	    return _defineProperty(func, 'toString', {
	      'configurable': true,
	      'enumerable': false,
	      'value': constant_1(string),
	      'writable': true
	    });
	  };

	  var _baseSetToString = baseSetToString;

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /* Built-in method references for those with the same name as other `lodash` methods. */
	  var nativeNow = Date.now;

	  /**
	   * Creates a function that'll short out and invoke `identity` instead
	   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	   * milliseconds.
	   *
	   * @private
	   * @param {Function} func The function to restrict.
	   * @returns {Function} Returns the new shortable function.
	   */
	  function shortOut(func) {
	    var count = 0,
	        lastCalled = 0;

	    return function() {
	      var stamp = nativeNow(),
	          remaining = HOT_SPAN - (stamp - lastCalled);

	      lastCalled = stamp;
	      if (remaining > 0) {
	        if (++count >= HOT_COUNT) {
	          return arguments[0];
	        }
	      } else {
	        count = 0;
	      }
	      return func.apply(undefined, arguments);
	    };
	  }

	  var _shortOut = shortOut;

	  /**
	   * Sets the `toString` method of `func` to return `string`.
	   *
	   * @private
	   * @param {Function} func The function to modify.
	   * @param {Function} string The `toString` result.
	   * @returns {Function} Returns `func`.
	   */
	  var setToString = _shortOut(_baseSetToString);

	  var _setToString = setToString;

	  /**
	   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	   *
	   * @private
	   * @param {Function} func The function to apply a rest parameter to.
	   * @param {number} [start=func.length-1] The start position of the rest parameter.
	   * @returns {Function} Returns the new function.
	   */
	  function baseRest(func, start) {
	    return _setToString(_overRest(func, start, identity_1), func + '');
	  }

	  var _baseRest = baseRest;

	  /**
	   * Checks if the given arguments are from an iteratee call.
	   *
	   * @private
	   * @param {*} value The potential iteratee value argument.
	   * @param {*} index The potential iteratee index or key argument.
	   * @param {*} object The potential iteratee object argument.
	   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	   *  else `false`.
	   */
	  function isIterateeCall(value, index, object) {
	    if (!isObject_1(object)) {
	      return false;
	    }
	    var type = typeof index;
	    if (type == 'number'
	          ? (isArrayLike_1(object) && _isIndex(index, object.length))
	          : (type == 'string' && index in object)
	        ) {
	      return eq_1(object[index], value);
	    }
	    return false;
	  }

	  var _isIterateeCall = isIterateeCall;

	  /**
	   * Creates a function like `_.assign`.
	   *
	   * @private
	   * @param {Function} assigner The function to assign values.
	   * @returns {Function} Returns the new assigner function.
	   */
	  function createAssigner(assigner) {
	    return _baseRest(function(object, sources) {
	      var index = -1,
	          length = sources.length,
	          customizer = length > 1 ? sources[length - 1] : undefined,
	          guard = length > 2 ? sources[2] : undefined;

	      customizer = (assigner.length > 3 && typeof customizer == 'function')
	        ? (length--, customizer)
	        : undefined;

	      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
	        customizer = length < 3 ? undefined : customizer;
	        length = 1;
	      }
	      object = Object(object);
	      while (++index < length) {
	        var source = sources[index];
	        if (source) {
	          assigner(object, source, index, customizer);
	        }
	      }
	      return object;
	    });
	  }

	  var _createAssigner = createAssigner;

	  /**
	   * This method is like `_.assign` except that it recursively merges own and
	   * inherited enumerable string keyed properties of source objects into the
	   * destination object. Source properties that resolve to `undefined` are
	   * skipped if a destination value exists. Array and plain object properties
	   * are merged recursively. Other objects and value types are overridden by
	   * assignment. Source objects are applied from left to right. Subsequent
	   * sources overwrite property assignments of previous sources.
	   *
	   * **Note:** This method mutates `object`.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.5.0
	   * @category Object
	   * @param {Object} object The destination object.
	   * @param {...Object} [sources] The source objects.
	   * @returns {Object} Returns `object`.
	   * @example
	   *
	   * var object = {
	   *   'a': [{ 'b': 2 }, { 'd': 4 }]
	   * };
	   *
	   * var other = {
	   *   'a': [{ 'c': 3 }, { 'e': 5 }]
	   * };
	   *
	   * _.merge(object, other);
	   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	   */
	  var merge = _createAssigner(function(object, source, srcIndex) {
	    _baseMerge(object, source, srcIndex);
	  });

	  var merge_1 = merge;

	  //
	  //
	  //
	  //
	  //
	  //
	  var script = {};

	  /* script */
	              var __vue_script__ = script;
	              
	  /* template */
	  var __vue_render__ = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "dialog-layout" }, [_vm._t("default")], 2)
	  };
	  var __vue_staticRenderFns__ = [];
	  __vue_render__._withStripped = true;

	    /* style */
	    var __vue_inject_styles__ = undefined;
	    /* scoped */
	    var __vue_scope_id__ = undefined;
	    /* module identifier */
	    var __vue_module_identifier__ = undefined;
	    /* functional template */
	    var __vue_is_functional_template__ = false;
	    /* component normalizer */
	    function __vue_normalize__(
	      template, style, script$$1,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DefaultLayout.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var DefaultLayout = __vue_normalize__(
	      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	      __vue_inject_styles__,
	      __vue_script__,
	      __vue_scope_id__,
	      __vue_is_functional_template__,
	      __vue_module_identifier__,
	      __vue_create_injector__,
	      undefined
	    );

	  /*
	   * vuedl
	   *
	   * (c) Savaryn Yaroslav <yariksav@gmail.com>
	   *
	   * Some functions was imported from nuxt.js/lib/app/utils.js
	   * For the full copyright and license information, please view the LICENSE
	   * file that was distributed with this source code.
	  */

	  var noopData = function () { return ({}); };

	  function promisify(fn, context) {
	    var promise;

	    if (fn.length === 2) {
	      // fn(context, callback)
	      promise = new Promise(function (resolve) {
	        fn(context, function (err, data) {
	          if (err) {
	            context.error(err);
	          }

	          data = data || {};
	          resolve(data);
	        });
	      });
	    } else {
	      promise = fn(context);
	    }

	    if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {
	      promise = Promise.resolve(promise);
	    }

	    return promise;
	  }
	  function destroyVueElement(vm) {
	    if (vm && !vm._isDestroyed && typeof vm.$destroy === 'function') {
	      vm.$destroy();
	    }
	  }
	  function findContainer(container) {
	    var found;

	    if (typeof container === 'string') {
	      found = document.querySelector(container);
	    } else {
	      found = container;
	    }

	    if (!found) {
	      found = document.body;
	    }

	    return found;
	  }
	  function applyAsyncData(Component, asyncData) {
	    var ComponentData = Component.options.data || noopData; // Prevent calling this method for each request on SSR context

	    if (!asyncData && Component.options.hasAsyncData) {
	      return;
	    }

	    Component.options.hasAsyncData = true;

	    Component.options.data = function () {
	      var data = ComponentData.call(this);

	      if (this.$ssrContext) {
	        asyncData = this.$ssrContext.asyncData[Component.cid];
	      }

	      return Object.assign({}, data, asyncData);
	    };

	    if (Component._Ctor && Component._Ctor.options) {
	      Component._Ctor.options.data = Component.options.data;
	    }
	  }
	  function ensureAsyncDatas(components, context) {
	    return new Promise(function ($return, $error) {
	      if (!Array.isArray(components)) {
	        if (!components) {
	          return $return(null);
	        } else {
	          components = [components];
	        }
	      }

	      return $return(Promise.all(components.map(function (Component) {
	        var promises = []; // Call asyncData(context)

	        if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {
	          var promise = promisify(Component.options.asyncData, context);
	          promise.then(function (asyncDataResult) {
	            // ssrContext.asyncData[Component.cid] = asyncDataResult
	            applyAsyncData(Component, asyncDataResult);
	            return asyncDataResult;
	          });
	          promises.push(promise);
	        } else {
	          promises.push(null);
	        } // Call fetch(context)


	        if (Component.options.fetch) {
	          promises.push(Component.options.fetch(context));
	        } else {
	          promises.push(null);
	        }

	        return Promise.all(promises);
	      })));
	    });
	  }

	  /**
	   * Helpers.
	   */

	  var s = 1000;
	  var m = s * 60;
	  var h = m * 60;
	  var d = h * 24;
	  var y = d * 365.25;

	  /**
	   * Parse or format the given `val`.
	   *
	   * Options:
	   *
	   *  - `long` verbose formatting [false]
	   *
	   * @param {String|Number} val
	   * @param {Object} [options]
	   * @throws {Error} throw an error if val is not a non-empty string or a number
	   * @return {String|Number}
	   * @api public
	   */

	  var ms = function(val, options) {
	    options = options || {};
	    var type = typeof val;
	    if (type === 'string' && val.length > 0) {
	      return parse(val);
	    } else if (type === 'number' && isNaN(val) === false) {
	      return options.long ? fmtLong(val) : fmtShort(val);
	    }
	    throw new Error(
	      'val is not a non-empty string or a valid number. val=' +
	        JSON.stringify(val)
	    );
	  };

	  /**
	   * Parse the given `str` and return milliseconds.
	   *
	   * @param {String} str
	   * @return {Number}
	   * @api private
	   */

	  function parse(str) {
	    str = String(str);
	    if (str.length > 100) {
	      return;
	    }
	    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	      str
	    );
	    if (!match) {
	      return;
	    }
	    var n = parseFloat(match[1]);
	    var type = (match[2] || 'ms').toLowerCase();
	    switch (type) {
	      case 'years':
	      case 'year':
	      case 'yrs':
	      case 'yr':
	      case 'y':
	        return n * y;
	      case 'days':
	      case 'day':
	      case 'd':
	        return n * d;
	      case 'hours':
	      case 'hour':
	      case 'hrs':
	      case 'hr':
	      case 'h':
	        return n * h;
	      case 'minutes':
	      case 'minute':
	      case 'mins':
	      case 'min':
	      case 'm':
	        return n * m;
	      case 'seconds':
	      case 'second':
	      case 'secs':
	      case 'sec':
	      case 's':
	        return n * s;
	      case 'milliseconds':
	      case 'millisecond':
	      case 'msecs':
	      case 'msec':
	      case 'ms':
	        return n;
	      default:
	        return undefined;
	    }
	  }

	  /**
	   * Short format for `ms`.
	   *
	   * @param {Number} ms
	   * @return {String}
	   * @api private
	   */

	  function fmtShort(ms) {
	    if (ms >= d) {
	      return Math.round(ms / d) + 'd';
	    }
	    if (ms >= h) {
	      return Math.round(ms / h) + 'h';
	    }
	    if (ms >= m) {
	      return Math.round(ms / m) + 'm';
	    }
	    if (ms >= s) {
	      return Math.round(ms / s) + 's';
	    }
	    return ms + 'ms';
	  }

	  /**
	   * Long format for `ms`.
	   *
	   * @param {Number} ms
	   * @return {String}
	   * @api private
	   */

	  function fmtLong(ms) {
	    return plural(ms, d, 'day') ||
	      plural(ms, h, 'hour') ||
	      plural(ms, m, 'minute') ||
	      plural(ms, s, 'second') ||
	      ms + ' ms';
	  }

	  /**
	   * Pluralization helper.
	   */

	  function plural(ms, n, name) {
	    if (ms < n) {
	      return;
	    }
	    if (ms < n * 1.5) {
	      return Math.floor(ms / n) + ' ' + name;
	    }
	    return Math.ceil(ms / n) + ' ' + name + 's';
	  }

	  var debug = createCommonjsModule$$1(function (module, exports) {
	  /**
	   * This is the common logic for both the Node.js and web browser
	   * implementations of `debug()`.
	   *
	   * Expose `debug()` as the module.
	   */

	  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	  exports.coerce = coerce;
	  exports.disable = disable;
	  exports.enable = enable;
	  exports.enabled = enabled;
	  exports.humanize = ms;

	  /**
	   * Active `debug` instances.
	   */
	  exports.instances = [];

	  /**
	   * The currently active debug mode names, and names to skip.
	   */

	  exports.names = [];
	  exports.skips = [];

	  /**
	   * Map of special "%n" handling functions, for the debug "format" argument.
	   *
	   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	   */

	  exports.formatters = {};

	  /**
	   * Select a color.
	   * @param {String} namespace
	   * @return {Number}
	   * @api private
	   */

	  function selectColor(namespace) {
	    var hash = 0, i;

	    for (i in namespace) {
	      hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	      hash |= 0; // Convert to 32bit integer
	    }

	    return exports.colors[Math.abs(hash) % exports.colors.length];
	  }

	  /**
	   * Create a debugger with the given `namespace`.
	   *
	   * @param {String} namespace
	   * @return {Function}
	   * @api public
	   */

	  function createDebug(namespace) {

	    var prevTime;

	    function debug() {
	      // disabled?
	      if (!debug.enabled) return;

	      var self = debug;

	      // set `diff` timestamp
	      var curr = +new Date();
	      var ms$$1 = curr - (prevTime || curr);
	      self.diff = ms$$1;
	      self.prev = prevTime;
	      self.curr = curr;
	      prevTime = curr;

	      // turn the `arguments` into a proper Array
	      var args = new Array(arguments.length);
	      for (var i = 0; i < args.length; i++) {
	        args[i] = arguments[i];
	      }

	      args[0] = exports.coerce(args[0]);

	      if ('string' !== typeof args[0]) {
	        // anything else let's inspect with %O
	        args.unshift('%O');
	      }

	      // apply any `formatters` transformations
	      var index = 0;
	      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	        // if we encounter an escaped % then don't increase the array index
	        if (match === '%%') return match;
	        index++;
	        var formatter = exports.formatters[format];
	        if ('function' === typeof formatter) {
	          var val = args[index];
	          match = formatter.call(self, val);

	          // now we need to remove `args[index]` since it's inlined in the `format`
	          args.splice(index, 1);
	          index--;
	        }
	        return match;
	      });

	      // apply env-specific formatting (colors, etc.)
	      exports.formatArgs.call(self, args);

	      var logFn = debug.log || exports.log || console.log.bind(console);
	      logFn.apply(self, args);
	    }

	    debug.namespace = namespace;
	    debug.enabled = exports.enabled(namespace);
	    debug.useColors = exports.useColors();
	    debug.color = selectColor(namespace);
	    debug.destroy = destroy;

	    // env-specific initialization logic for debug instances
	    if ('function' === typeof exports.init) {
	      exports.init(debug);
	    }

	    exports.instances.push(debug);

	    return debug;
	  }

	  function destroy () {
	    var index = exports.instances.indexOf(this);
	    if (index !== -1) {
	      exports.instances.splice(index, 1);
	      return true;
	    } else {
	      return false;
	    }
	  }

	  /**
	   * Enables a debug mode by namespaces. This can include modes
	   * separated by a colon and wildcards.
	   *
	   * @param {String} namespaces
	   * @api public
	   */

	  function enable(namespaces) {
	    exports.save(namespaces);

	    exports.names = [];
	    exports.skips = [];

	    var i;
	    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	    var len = split.length;

	    for (i = 0; i < len; i++) {
	      if (!split[i]) continue; // ignore empty strings
	      namespaces = split[i].replace(/\*/g, '.*?');
	      if (namespaces[0] === '-') {
	        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	      } else {
	        exports.names.push(new RegExp('^' + namespaces + '$'));
	      }
	    }

	    for (i = 0; i < exports.instances.length; i++) {
	      var instance = exports.instances[i];
	      instance.enabled = exports.enabled(instance.namespace);
	    }
	  }

	  /**
	   * Disable debug output.
	   *
	   * @api public
	   */

	  function disable() {
	    exports.enable('');
	  }

	  /**
	   * Returns true if the given mode name is enabled, false otherwise.
	   *
	   * @param {String} name
	   * @return {Boolean}
	   * @api public
	   */

	  function enabled(name) {
	    if (name[name.length - 1] === '*') {
	      return true;
	    }
	    var i, len;
	    for (i = 0, len = exports.skips.length; i < len; i++) {
	      if (exports.skips[i].test(name)) {
	        return false;
	      }
	    }
	    for (i = 0, len = exports.names.length; i < len; i++) {
	      if (exports.names[i].test(name)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Coerce `val`.
	   *
	   * @param {Mixed} val
	   * @return {Mixed}
	   * @api private
	   */

	  function coerce(val) {
	    if (val instanceof Error) return val.stack || val.message;
	    return val;
	  }
	  });
	  var debug_1 = debug.coerce;
	  var debug_2 = debug.disable;
	  var debug_3 = debug.enable;
	  var debug_4 = debug.enabled;
	  var debug_5 = debug.humanize;
	  var debug_6 = debug.instances;
	  var debug_7 = debug.names;
	  var debug_8 = debug.skips;
	  var debug_9 = debug.formatters;

	  var browser = createCommonjsModule$$1(function (module, exports) {
	  /**
	   * This is the web browser implementation of `debug()`.
	   *
	   * Expose `debug()` as the module.
	   */

	  exports = module.exports = debug;
	  exports.log = log;
	  exports.formatArgs = formatArgs;
	  exports.save = save;
	  exports.load = load;
	  exports.useColors = useColors;
	  exports.storage = 'undefined' != typeof chrome
	                 && 'undefined' != typeof chrome.storage
	                    ? chrome.storage.local
	                    : localstorage();

	  /**
	   * Colors.
	   */

	  exports.colors = [
	    '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
	    '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
	    '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
	    '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
	    '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
	    '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
	    '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
	    '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
	    '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
	    '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
	    '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
	  ];

	  /**
	   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	   * and the Firebug extension (any Firefox version) are known
	   * to support "%c" CSS customizations.
	   *
	   * TODO: add a `localStorage` variable to explicitly enable/disable colors
	   */

	  function useColors() {
	    // NB: In an Electron preload script, document will be defined but not fully
	    // initialized. Since we know we're in Chrome, we'll just detect this case
	    // explicitly
	    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	      return true;
	    }

	    // Internet Explorer and Edge do not support colors.
	    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	      return false;
	    }

	    // is webkit? http://stackoverflow.com/a/16459606/376773
	    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	      // is firebug? http://stackoverflow.com/a/398120/376773
	      (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	      // is firefox >= v31?
	      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	      // double check webkit in userAgent just in case we are in a worker
	      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	  }

	  /**
	   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	   */

	  exports.formatters.j = function(v) {
	    try {
	      return JSON.stringify(v);
	    } catch (err) {
	      return '[UnexpectedJSONParseError]: ' + err.message;
	    }
	  };


	  /**
	   * Colorize log arguments if enabled.
	   *
	   * @api public
	   */

	  function formatArgs(args) {
	    var useColors = this.useColors;

	    args[0] = (useColors ? '%c' : '')
	      + this.namespace
	      + (useColors ? ' %c' : ' ')
	      + args[0]
	      + (useColors ? '%c ' : ' ')
	      + '+' + exports.humanize(this.diff);

	    if (!useColors) return;

	    var c = 'color: ' + this.color;
	    args.splice(1, 0, c, 'color: inherit');

	    // the final "%c" is somewhat tricky, because there could be other
	    // arguments passed either before or after the %c, so we need to
	    // figure out the correct index to insert the CSS into
	    var index = 0;
	    var lastC = 0;
	    args[0].replace(/%[a-zA-Z%]/g, function(match) {
	      if ('%%' === match) return;
	      index++;
	      if ('%c' === match) {
	        // we only are interested in the *last* %c
	        // (the user may have provided their own)
	        lastC = index;
	      }
	    });

	    args.splice(lastC, 0, c);
	  }

	  /**
	   * Invokes `console.log()` when available.
	   * No-op when `console.log` is not a "function".
	   *
	   * @api public
	   */

	  function log() {
	    // this hackery is required for IE8/9, where
	    // the `console.log` function doesn't have 'apply'
	    return 'object' === typeof console
	      && console.log
	      && Function.prototype.apply.call(console.log, console, arguments);
	  }

	  /**
	   * Save `namespaces`.
	   *
	   * @param {String} namespaces
	   * @api private
	   */

	  function save(namespaces) {
	    try {
	      if (null == namespaces) {
	        exports.storage.removeItem('debug');
	      } else {
	        exports.storage.debug = namespaces;
	      }
	    } catch(e) {}
	  }

	  /**
	   * Load `namespaces`.
	   *
	   * @return {String} returns the previously persisted debug modes
	   * @api private
	   */

	  function load() {
	    var r;
	    try {
	      r = exports.storage.debug;
	    } catch(e) {}

	    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	    if (!r && typeof process !== 'undefined' && 'env' in process) {
	      r = process.env.DEBUG;
	    }

	    return r;
	  }

	  /**
	   * Enable namespaces listed in `localStorage.debug` initially.
	   */

	  exports.enable(load());

	  /**
	   * Localstorage attempts to return the localstorage.
	   *
	   * This is necessary because safari throws
	   * when a user disables cookies/localstorage
	   * and you attempt to access it.
	   *
	   * @return {LocalStorage}
	   * @api private
	   */

	  function localstorage() {
	    try {
	      return window.localStorage;
	    } catch (e) {}
	  }
	  });
	  var browser_1 = browser.log;
	  var browser_2 = browser.formatArgs;
	  var browser_3 = browser.save;
	  var browser_4 = browser.load;
	  var browser_5 = browser.useColors;
	  var browser_6 = browser.storage;
	  var browser_7 = browser.colors;

	  /*
	   * vuedl
	   *
	   * (c) Savaryn Yaroslav <yariksav@gmail.com>
	   *
	   * For the full copyright and license information, please view the LICENSE
	   * file that was distributed with this source code.
	  */
	  var debug$1 = browser('vuedl:dialog');
	  var seed = 1;
	  var Dialog = function Dialog(component, ref) {
	    if ( ref === void 0 ) ref = {};
	    var layout = ref.layout;
	    var container = ref.container;

	    if (!component) {
	      throw Error('Component was not setted');
	    }

	    this._layout = layout || {
	      component: DefaultLayout,
	      options: {}
	    };
	    this._component = component;
	    this._vm = null;
	    this._vmDialog = null;
	    this._options = {};
	    this.id = ++seed;
	    this._resolvers = [];
	    this.container = findContainer(container);
	    debug$1('created');
	  };

	  var prototypeAccessors = { showed: { configurable: true },element: { configurable: true },hasAsyncPreload: { configurable: true },vm: { configurable: true },vmd: { configurable: true } };

	  Dialog.prototype.show = function show (params, options) {
	      if ( params === void 0 ) params = {};
	      if ( options === void 0 ) options = {};

	    return new Promise(function ($return, $error) {
	      var LayoutCtor, layout, DialogCtor, dialog;
	      if (Vue.prototype.$isServer) { return $return(); }
	      debug$1('before show', {
	        params: params,
	        options: options
	      }); // create layout

	      LayoutCtor = Vue.extend(this._layout.component);
	      LayoutCtor = LayoutCtor.extend({
	        mixins: [Layoutable],
	        destroyed: this._onDestroyed.bind(this)
	      });
	      layout = new LayoutCtor(merge_1({
	        propsData: Object.assign({}, this._layout.options, params)
	      }, this.context, options));
	      DialogCtor = Vue.extend(Object.assign({}, this._component, {
	        parent: layout
	      }));

	      if (this._component.primaryKey) {
	        DialogCtor = DialogCtor.extend({
	          mixins: [Recordable]
	        });
	      }

	      if (this.hasAsyncPreload) {
	        var res;
	        return Promise.resolve(ensureAsyncDatas(DialogCtor, Object.assign({}, this.context, {
	          params: params
	        }))).then(function ($await_2) {
	          try {
	            res = $await_2;
	            debug$1('async datas', res);
	            return $If_1.call(this);
	          } catch ($boundEx) {
	            return $error($boundEx);
	          }
	        }.bind(this), $error);
	      }

	      function $If_1() {
	        dialog = new DialogCtor(merge_1({
	          propsData: params
	        }, this.context, options));
	        // mounting
	        dialog.$mount();
	        layout.$slots.default = dialog._vnode;
	        layout.$mount();
	        layout.$on('submit', this.onReturn.bind(this));
	        dialog.$on('submit', this.onReturn.bind(this));
	        this._vm = layout;
	        this._vm._dialogInstance = dialog;
	        this._vmDialog = dialog;
	        this.container = options.container ? findContainer(options.container) : this.container;
	        this.container.appendChild(this.element);
	        return $return(this);
	      }

	      return $If_1.call(this);
	    }.bind(this));
	  };

	  Dialog.prototype.wait = function wait () {
	      var this$1 = this;

	    // if (!this.showed) {
	    // return Promise.reject(new Error('Dialog was closed or not showed'))
	    // }
	    return new Promise(function (resolve) {
	      this$1._resolvers.push(resolve);
	    });
	  };

	  Dialog.prototype._onDestroyed = function _onDestroyed () {
	    this.remove();
	  };

	  Dialog.prototype.remove = function remove () {
	    debug$1('remove');
	    this.onDestroyed && this.onDestroyed(this); // this.element.parentNode.removeChild(this.element)

	    this._processResultPromises();

	    destroyVueElement(this._vm);
	    destroyVueElement(this._vmDialog);
	    this._vm = null;
	    this._vmDialog = null;
	  };

	  Dialog.prototype._processResultPromises = function _processResultPromises (result) {
	    if (!this._resolvers.length) {
	      return;
	    }

	    debug$1('processResultPromises', result);

	    this._resolvers.forEach(function (resolver) { return resolver(result); });

	    this._resolvers = [];
	  };

	  Dialog.prototype.onReturn = function onReturn (result) {
	    debug$1('onReturn', result);

	    this._processResultPromises(result);

	    this.close();
	  };

	  prototypeAccessors.showed.get = function () {
	    return !!this._vm && !this._vm._isDestroyed;
	  };

	  prototypeAccessors.element.get = function () {
	    return this._vm && this._vm.$el;
	  };

	  prototypeAccessors.hasAsyncPreload.get = function () {
	    return this._component && (this._component.asyncData || this._component.fetch);
	  };

	  prototypeAccessors.vm.get = function () {
	    return this._vm;
	  };

	  prototypeAccessors.vmd.get = function () {
	    return this._vmDialog;
	  };

	  Dialog.prototype.close = function close () {
	    this._vm.close();
	  };

	  Object.defineProperties( Dialog.prototype, prototypeAccessors );

	  /*
	   * vuedl
	   *
	   * (c) Savaryn Yaroslav <yariksav@gmail.com>
	   *
	   * For the full copyright and license information, please view the LICENSE
	   * file that was distributed with this source code.
	  */
	  var Overlay = function Overlay(component) {
	    this._component = component;
	    this._vm = null;
	  };

	  Overlay.prototype.show = function show () {
	    if (!this._vm) {
	      var Ctor = Vue.extend(this._component);
	      this._vm = new Ctor(); // {propsData: { visible: true }}

	      this._vm.$mount();

	      document.body.appendChild(this._vm.$el);
	    }

	    this._vm.visible = true;
	  };

	  Overlay.prototype.hide = function hide () {
	    this._vm.visible = false;
	  };

	  /*
	   * vuedl
	   *
	   * (c) Savaryn Yaroslav <yariksav@gmail.com>
	   *
	   * For the full copyright and license information, please view the LICENSE
	   * file that was distributed with this source code.
	  */

	  var proxyHandler = {
	    get: function get(target, name) {
	      /**
	       * if node is inspecting then stick to target properties
	       */
	      if (typeof name === 'symbol' || name === 'inspect') {
	        return target[name];
	      }

	      if (target[name]) {
	        return target[name];
	      }

	      if (target._components[name]) {
	        return target.createFunctionWrapper(name);
	      }

	      return target[name];
	    }

	  };
	  var DialogManager = function DialogManager(ref) {
	    if ( ref === void 0 ) ref = {};
	    var context = ref.context;
	    var container = ref.container;

	    this._context = context || {};
	    Dialog.prototype.context = context || {};
	    this._components = {};
	    this._layouts = {};
	    this._overlays = {};
	    this._container = container;
	    this._emitter = new Vue({});
	    this._instances = []; // this.initEmitter()

	    return new Proxy(this, proxyHandler);
	  };

	  var prototypeAccessors$1 = { context: { configurable: true } }; // initEmitter () {
	  // this._emitter.$on('shown', ({ dialog }) => {
	  //   const position = dialog.vm.position
	  //   let verticalOffset = notificationGap
	  //   this._instances.filter(item => item.vm.position === position).forEach(item => {
	  //     verticalOffset += item.element.offsetHeight + notificationGap
	  //   })
	  //   this._instances.push(dialog)
	  //   dialog.vm.verticalOffset = verticalOffset
	  // })
	  // this._emitter.$on('destroyed', ({ dialog }) => {
	  //   let index = this._instances.findIndex(instance => instance.id === dialog.id)
	  //   if (index < 0) {
	  //     return
	  //   }
	  //   this._instances.splice(index, 1)
	  //   // console.log('instances', this._instances)
	  //   const len = this._instances.length
	  //   const position = dialog.vm.position
	  //   if (!len) return
	  //   let verticalOffset = notificationGap
	  //   this._instances.filter(item => item.vm.position === position).forEach(item => {
	  //     item.vm.verticalOffset = verticalOffset
	  //     verticalOffset += item.element.offsetHeight + notificationGap
	  //   })
	  // })
	  // }


	  prototypeAccessors$1.context.get = function () {
	    return this._context;
	  };

	  DialogManager.prototype.layout = function layout (name, component, options) {
	      if ( options === void 0 ) options = {};

	    this._layouts[name] = {
	      component: component,
	      options: options
	    };
	  };

	  DialogManager.prototype.getLayout = function getLayout (layout) {
	    if (typeof layout === 'function') {
	      var options = layout.call(this);
	      layout = this._layouts[options.name || 'default'];
	      return Object.assign({}, layout, {
	        options: options
	      });
	    }

	    if (typeof layout === 'object' && typeof layout.render === 'function') {
	      return {
	        component: layout
	      };
	    }

	    if (Array.isArray(layout)) {
	      var nameTmp = layout[0];
	      var optionsTmp = layout[1] || {};
	      var instance = typeof nameTmp === 'object' && typeof nameTmp.render === 'function' ? {
	        component: nameTmp
	      } : this._layouts[nameTmp];
	      return instance && {
	        component: instance.component,
	        options: Object.assign({}, instance.options, optionsTmp)
	      };
	    }

	    return this._layouts[layout];
	  };

	  DialogManager.prototype.overlay = function overlay (name, component) {
	    if (component === undefined) {
	      if (this._overlays[name]) {
	        return this._overlays[name];
	      } else {
	        throw new Error(("Overlay \"" + name + " not found\n          Please register it by calling dialog.overlay('" + name + "', component)"));
	      }
	    }

	    this._overlays[name] = new Overlay(component);
	  };

	  DialogManager.prototype.getComponent = function getComponent (name) {
	    if (!this._components[name]) {
	      throw new Error(("Component \"" + name + "\" was not found.\n        Please register it by calling dialog.register('" + name + "', component)"));
	    }

	    return this._components[name];
	  };

	  DialogManager.prototype.component = function component (name, component$1, options) {
	      if ( options === void 0 ) options = {};

	    if (component$1 === undefined) {
	      return this._components[name];
	    }

	    this._components[name] = {
	      component: component$1,
	      options: options
	    };
	  };

	  DialogManager.prototype.create = function create (component) {
	    if (!component) {
	      throw new Error('Component is incorrect');
	    }

	    var layout = this.getLayout(component.layout || 'default');
	    var dlg = new Dialog(component, {
	      layout: layout,
	      context: this._context,
	      container: this._container
	    });

	    this._emitter.$emit('created', {
	      dialog: dlg
	    });

	    return dlg;
	  };

	  DialogManager.prototype.show = function show (component, options) {
	      if ( options === void 0 ) options = {};

	    return new Promise(function ($return, $error) {
	      var dlg, overlayName, overlay;
	      dlg = this.create(component);
	      overlayName = dlg.hasAsyncPreload ? component.overlay || 'default' : false;
	      overlay = overlayName && this._overlays[overlayName] && this.overlay(overlayName);
	      overlay && overlay.show();

	      var $Try_1_Catch = function (e) {
	        try {
	          this._emitter.$emit('error', {
	            error: e,
	            dialog: dlg
	          });

	          overlay && overlay.hide();
	          throw e;
	        } catch ($boundEx) {
	          return $error($boundEx);
	        }
	      }.bind(this);

	      try {
	        return Promise.resolve(dlg.show(options)).then(function ($await_2) {
	          try {
	            this._emitter.$emit('shown', {
	              dialog: dlg
	            });

	            overlay && overlay.hide();
	            dlg.onDestroyed = this.onDialogDestroyed.bind(this);
	            return $return(options.waitForResult ? dlg.wait() : dlg);
	          } catch ($boundEx) {
	            return $Try_1_Catch($boundEx);
	          }
	        }.bind(this), $Try_1_Catch);
	      } catch (e) {
	        $Try_1_Catch(e);
	      }
	    }.bind(this));
	  };

	  DialogManager.prototype.createFunctionWrapper = function createFunctionWrapper (name) {
	      var this$1 = this;

	    var cmp = this.getComponent(name);
	    return function (options) { return this$1.show(cmp.component, Object.assign({}, cmp.options, options)); };
	  };

	  DialogManager.prototype.showAndWait = function showAndWait (component, props) {
	    return new Promise(function ($return, $error) {
	      var dlg;
	      return Promise.resolve(this.show(component, props)).then(function ($await_3) {
	        try {
	          dlg = $await_3;
	          return $return(dlg.wait());
	        } catch ($boundEx) {
	          return $error($boundEx);
	        }
	      }, $error);
	    }.bind(this));
	  };

	  DialogManager.prototype.on = function on (event, callback) {
	    this._emitter.$on(event, callback);
	  };

	  DialogManager.prototype.off = function off (event, callback) {
	    this._emitter.$off(event, callback);
	  };

	  DialogManager.prototype.once = function once (event, callback) {
	    this._emitter.$once(event, callback);
	  };

	  DialogManager.prototype.onDialogDestroyed = function onDialogDestroyed (dialog) {
	    this._emitter.$emit('destroyed', {
	      dialog: dialog
	    });
	  };

	  Object.defineProperties( DialogManager.prototype, prototypeAccessors$1 );

	  //
	  //
	  //
	  //
	  //
	  //
	  //
	  //
	  //
	  //
	  var script$1 = {
	    props: {
	      width: Number,
	      persistent: Boolean
	    }
	  };

	  /* script */
	              var __vue_script__$1 = script$1;
	              
	  /* template */
	  var __vue_render__$1 = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("transition", { attrs: { name: "vdialog-modal" } }, [
	      _c(
	        "div",
	        {
	          staticClass: "vdialog-modal-mask",
	          on: {
	            click: function($event) {
	              if ($event.target !== $event.currentTarget) {
	                return null
	              }
	              $event.preventDefault();
	              $event.stopPropagation();
	              return _vm.dismiss($event)
	            }
	          }
	        },
	        [
	          _c(
	            "div",
	            {
	              staticClass: "vdialog-modal-container",
	              style: { "max-width": (_vm.width || 500) + "px" }
	            },
	            [
	              _c(
	                "dialog-child",
	                _vm._b({}, "dialog-child", _vm.$options.propsData, false)
	              )
	            ],
	            1
	          )
	        ]
	      )
	    ])
	  };
	  var __vue_staticRenderFns__$1 = [];
	  __vue_render__$1._withStripped = true;

	    /* style */
	    var __vue_inject_styles__$1 = function (inject) {
	      if (!inject) { return }
	      inject("data-v-5c224c04_0", { source: "\n.vdialog-modal-mask {\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  position: fixed;\n  top: 0;\n  transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\n  width: 100%;\n  z-index: 6;\n  outline: none;\n  background-color: rgba(0, 0, 0, .5);\n}\n.vdialog-modal-container {\n  overflow-y: auto;\n  max-height: 95%;\n  background-color: #fff;\n  box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\n  border-radius: 2px;\n  margin: 12px;\n  overflow-y: auto;\n  pointer-events: auto;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n  width: 100%;\n  z-index: inherit;\n}\n\n/*\n* The following styles are auto-applied to elements with\n* transition=\"modal\" when their visibility is toggled\n* by Vue.js.\n*\n* You can easily play with the modal transition by editing\n* these styles.\n*/\n.vdialog-modal-enter {\n  opacity: 0;\n}\n.vdialog-modal-leave-active {\n  opacity: 0;\n}\n.vdialog-modal-enter .modal-container,\n.vdialog-modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue"],"names":[],"mappings":";AAqBA;EACA,oBAAA;EACA,cAAA;EACA,aAAA;EACA,wBAAA;EACA,QAAA;EACA,gBAAA;EACA,OAAA;EACA,kDAAA;EACA,YAAA;EACA,WAAA;EACA,cAAA;EACA,oCAAA;CACA;AAEA;EACA,iBAAA;EACA,gBAAA;EACA,uBAAA;EACA,sHAAA;EACA,mBAAA;EACA,aAAA;EACA,iBAAA;EACA,qBAAA;EACA,kDAAA;EACA,YAAA;EACA,iBAAA;CACA;;AAEA;;;;;;;EAOA;AAEA;EACA,WAAA;CACA;AAEA;EACA,WAAA;CACA;AAEA;;EAEA,8BAAA;EACA,sBAAA;CACA","file":"DialogLayout.vue","sourcesContent":["<template>\n  <transition name=\"vdialog-modal\">\n    <div class=\"vdialog-modal-mask\" @click.self.prevent.stop=\"dismiss\">\n        <div class=\"vdialog-modal-container\" :style=\"{ 'max-width': (width || 500) +'px' }\">\n          <dialog-child v-bind=\"$options.propsData\"/>\n        </div>\n    </div>\n  </transition>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    width: Number,\n    persistent: Boolean\n  }\n}\n</script>\n\n<style>\n  .vdialog-modal-mask {\n    align-items: center;\n    display: flex;\n    height: 100%;\n    justify-content: center;\n    left: 0;\n    position: fixed;\n    top: 0;\n    transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\n    width: 100%;\n    z-index: 6;\n    outline: none;\n    background-color: rgba(0, 0, 0, .5);\n  }\n\n  .vdialog-modal-container {\n    overflow-y: auto;\n    max-height: 95%;\n    background-color: #fff;\n    box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\n    border-radius: 2px;\n    margin: 12px;\n    overflow-y: auto;\n    pointer-events: auto;\n    transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n    width: 100%;\n    z-index: inherit;\n  }\n\n  /*\n  * The following styles are auto-applied to elements with\n  * transition=\"modal\" when their visibility is toggled\n  * by Vue.js.\n  *\n  * You can easily play with the modal transition by editing\n  * these styles.\n  */\n\n  .vdialog-modal-enter {\n    opacity: 0;\n  }\n\n  .vdialog-modal-leave-active {\n    opacity: 0;\n  }\n\n  .vdialog-modal-enter .modal-container,\n  .vdialog-modal-leave-active .modal-container {\n    -webkit-transform: scale(1.1);\n    transform: scale(1.1);\n  }\n</style>\n"]}, media: undefined });

	    };
	    /* scoped */
	    var __vue_scope_id__$1 = undefined;
	    /* module identifier */
	    var __vue_module_identifier__$1 = undefined;
	    /* functional template */
	    var __vue_is_functional_template__$1 = false;
	    /* component normalizer */
	    function __vue_normalize__$1(
	      template, style, script,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script === 'function' ? script.options : script) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      {
	        var hook;
	        if (style) {
	          hook = function(context) {
	            style.call(this, createInjector(context));
	          };
	        }

	        if (hook !== undefined) {
	          if (component.functional) {
	            // register for functional component in vue file
	            var originalRender = component.render;
	            component.render = function renderWithStyleInjection(h, context) {
	              hook.call(context);
	              return originalRender(h, context)
	            };
	          } else {
	            // inject component registration as beforeCreate hook
	            var existing = component.beforeCreate;
	            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	          }
	        }
	      }

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__$1() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var DialogLayout = __vue_normalize__$1(
	      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	      __vue_inject_styles__$1,
	      __vue_script__$1,
	      __vue_scope_id__$1,
	      __vue_is_functional_template__$1,
	      __vue_module_identifier__$1,
	      __vue_create_injector__$1,
	      undefined
	    );

	  var notifications = [];
	  var gap = 10;

	  var insertNotification = function (vm) {
	    var position = vm.position;
	    var verticalOffset = gap;
	    notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {
	      verticalOffset += item.$el.offsetHeight + gap;
	    });
	    notifications.push(vm);
	    vm.verticalOffset = verticalOffset;
	  };

	  var deleteNotification = function (vm) {
	    var index = notifications.findIndex(function (instance) { return instance === vm; });

	    if (index < 0) {
	      return;
	    }

	    notifications.splice(index, 1);
	    var len = notifications.length;
	    var position = vm.position;
	    if (!len) { return; }
	    var verticalOffset = gap;
	    notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {
	      item.verticalOffset = verticalOffset;
	      verticalOffset += item.$el.offsetHeight + gap;
	    });
	  };

	  var Notifiable = {
	    props: {
	      verticalOffset: Number,
	      showClose: {
	        type: Boolean,
	        default: function () { return true; }
	      },
	      position: {
	        type: String,
	        default: function () { return 'top-right'; }
	      },
	      timeout: {
	        type: Number,
	        default: function () { return 4500; }
	      },
	      width: {
	        type: Number,
	        default: function () { return 330; }
	      },
	      zIndex: {
	        type: Number,
	        default: function () { return 2000; }
	      }
	    },
	    computed: {
	      horizontalClass: function horizontalClass() {
	        return this.position.indexOf('right') > -1 ? 'right' : 'left';
	      },

	      verticalProperty: function verticalProperty() {
	        return /^top-/.test(this.position) ? 'top' : 'bottom';
	      },

	      getStyle: function getStyle() {
	        var obj;

	        return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + "px"), obj['max-width'] =  ((this.width) + "px"), obj['z-index'] =  this.zIndex, obj);
	      }

	    },
	    methods: {
	      _destroy: function _destroy() {
	        this.$el.addEventListener('transitionend', this.onTransitionEnd);
	      },

	      onTransitionEnd: function onTransitionEnd() {
	        this.$el.removeEventListener('transitionend', this.onTransitionEnd);
	        this.$destroy();
	      },

	      clearTimer: function clearTimer() {
	        clearTimeout(this.timer);
	      },

	      startTimer: function startTimer() {
	        if (this.timeout > 0) {
	          this.timer = setTimeout(this.close, this.timeout);
	        }
	      },

	      keydown: function keydown(e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          this.clearTimer(); // detele key
	        } else if (e.keyCode === 27) {
	          // esc key
	          this.close();
	        } else {
	          this.startTimer(); // any key
	        }
	      },

	      close: function close() {
	        this.isActive = false;
	      }

	    },
	    watch: {
	      isActive: function isActive(val) {
	        if (val) {
	          insertNotification(this);
	        } else {
	          deleteNotification(this);
	        }
	      }

	    },

	    mounted: function mounted() {
	      this.startTimer();
	      document.addEventListener('keydown', this.keydown);
	    },

	    beforeDestroy: function beforeDestroy() {
	      document.removeEventListener('keydown', this.keydown);
	    }

	  };

	  //
	  var script$2 = {
	    mixins: [Notifiable],
	    props: {
	      //   showClose: {
	      //     type: Boolean,
	      //     default: () => true
	      //   },
	      width: {
	        type: Number,
	        default: function () { return 330; }
	      }
	    },
	    computed: {
	      getStyle: function getStyle() {
	        var obj;

	        return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + "px"), obj['max-width'] =  ((this.width) + "px"), obj['z-index'] =  this.zIndex, obj);
	      }

	    } // methods: {
	    //   _destroy () {
	    //     this.$el.addEventListener('transitionend', this.onTransitionEnd)
	    //   },
	    //   onTransitionEnd () {
	    //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)
	    //     this.$destroy()
	    //   }
	    // }

	  };

	  /* script */
	              var __vue_script__$2 = script$2;
	              
	  /* template */
	  var __vue_render__$2 = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("transition", { attrs: { name: "vuedl-notification-fade" } }, [
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.isActive,
	              expression: "isActive"
	            }
	          ],
	          class: ["vuedl-notification", _vm.horizontalClass],
	          style: _vm.getStyle,
	          attrs: { role: "alert" },
	          on: { mouseenter: _vm.clearTimer, mouseleave: _vm.startTimer }
	        },
	        [
	          _vm._t("default"),
	          _vm._v(" "),
	          _vm.showClose
	            ? _c(
	                "div",
	                {
	                  staticClass: "vuedl-notification__closeBtn",
	                  on: {
	                    click: function($event) {
	                      $event.stopPropagation();
	                      return _vm.close($event)
	                    }
	                  }
	                },
	                [_vm._v("×")]
	              )
	            : _vm._e()
	        ],
	        2
	      )
	    ])
	  };
	  var __vue_staticRenderFns__$2 = [];
	  __vue_render__$2._withStripped = true;

	    /* style */
	    var __vue_inject_styles__$2 = function (inject) {
	      if (!inject) { return }
	      inject("data-v-f0792652_0", { source: "\n.vuedl-notification {\n   display:-webkit-box;\n   display:-ms-flexbox;\n   display:flex;\n   -webkit-box-sizing:border-box;\n   box-sizing:border-box;\n   position:fixed;\n   -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n   box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n   -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n   overflow:hidden\n}\n.vuedl-notification>div:first-child {\n   width: 100%\n}\n.vuedl-notification.right {\n   right:16px\n}\n.vuedl-notification.left {\n   left:16px\n}\n.vuedl-notification__closeBtn {\n   position:absolute;\n   top: 9px;\n   right: 15px;\n   cursor: pointer;\n   color: #909399;\n   font-size: 22px;\n}\n.vuedl-notification__closeBtn:hover {\n   color:#606266\n}\n.vuedl-notification-fade-enter.right{\n   right:0;\n   -webkit-transform:translateX(100%);\n   transform:translateX(100%)\n}\n.vuedl-notification-fade-enter.left{\n   left:0;\n   -webkit-transform:translateX(-100%);\n   transform:translateX(-100%)\n}\n.vuedl-notification-fade-leave-active {\n   opacity:0\n}\n@media screen and (max-width: 450px) {\n.vuedl-notification {\n     left:8px!important;\n     right:8px!important;\n     max-width: inherit!important;\n}\n}\n\n/* .el-notification-fade-enter {\n   &.right {\n     right: 0;\n     transform: translateX(100%);\n   }\n\n   &.left {\n     left: 0;\n     transform: translateX(-100%);\n   }\n }\n\n .el-notification-fade-leave-active {\n   opacity: 0;\n }*/\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue"],"names":[],"mappings":";AAwDA;GACA,oBAAA;GACA,oBAAA;GACA,aAAA;GACA,8BAAA;GACA,sBAAA;GACA,eAAA;GACA,+CAAA;GACA,uCAAA;GACA,2FAAA;GACA,mFAAA;GACA,2EAAA;GACA,iGAAA;GACA,eAAA;CACA;AACA;GACA,WAAA;CACA;AACA;GACA,UAAA;CACA;AACA;GACA,SAAA;CACA;AACA;GACA,kBAAA;GACA,SAAA;GACA,YAAA;GACA,gBAAA;GACA,eAAA;GACA,gBAAA;CACA;AACA;GACA,aAAA;CACA;AACA;GACA,QAAA;GACA,mCAAA;GACA,0BAAA;CACA;AACA;GACA,OAAA;GACA,oCAAA;GACA,2BAAA;CACA;AACA;GACA,SAAA;CACA;AACA;AACA;KACA,mBAAA;KACA,oBAAA;KACA,6BAAA;CACA;CACA;;AAEA;;;;;;;;;;;;;;IAcA","file":"NotificationLayout.vue","sourcesContent":["<template>\n  <transition name=\"vuedl-notification-fade\">\n    <div\n      :class=\"['vuedl-notification', horizontalClass]\"\n      v-show=\"isActive\"\n      :style=\"getStyle\"\n      @mouseenter=\"clearTimer\"\n      @mouseleave=\"startTimer\"\n      role=\"alert\"\n    >\n      <slot/>\n      <div\n        class=\"vuedl-notification__closeBtn\"\n        v-if=\"showClose\"\n        @click.stop=\"close\">×</div>\n    </div>\n  </transition>\n</template>\n\n<script>\n\nimport Notifiable from '../mixins/notifiable'\n\nexport default {\n  mixins: [ Notifiable ],\n  props: {\n  //   showClose: {\n  //     type: Boolean,\n  //     default: () => true\n  //   },\n    width: {\n      type: Number,\n      default: () => 330\n    }\n  },\n  computed: {\n    getStyle () {\n      return {\n        [this.verticalProperty]: `${this.verticalOffset}px`,\n        'max-width': `${this.width}px`,\n        'z-index': this.zIndex\n      }\n    }\n  }\n  // methods: {\n  //   _destroy () {\n  //     this.$el.addEventListener('transitionend', this.onTransitionEnd)\n  //   },\n  //   onTransitionEnd () {\n  //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)\n  //     this.$destroy()\n  //   }\n  // }\n}\n</script>\n<style>\n  .vuedl-notification {\n    display:-webkit-box;\n    display:-ms-flexbox;\n    display:flex;\n    -webkit-box-sizing:border-box;\n    box-sizing:border-box;\n    position:fixed;\n    -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n    box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\n    -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\n    overflow:hidden\n  }\n  .vuedl-notification>div:first-child {\n    width: 100%\n  }\n  .vuedl-notification.right {\n    right:16px\n  }\n  .vuedl-notification.left {\n    left:16px\n  }\n  .vuedl-notification__closeBtn {\n    position:absolute;\n    top: 9px;\n    right: 15px;\n    cursor: pointer;\n    color: #909399;\n    font-size: 22px;\n  }\n  .vuedl-notification__closeBtn:hover {\n    color:#606266\n  }\n  .vuedl-notification-fade-enter.right{\n    right:0;\n    -webkit-transform:translateX(100%);\n    transform:translateX(100%)\n  }\n  .vuedl-notification-fade-enter.left{\n    left:0;\n    -webkit-transform:translateX(-100%);\n    transform:translateX(-100%)\n  }\n  .vuedl-notification-fade-leave-active {\n    opacity:0\n  }\n  @media screen and (max-width: 450px) {\n    .vuedl-notification {\n      left:8px!important;\n      right:8px!important;\n      max-width: inherit!important;\n    }\n  }\n\n /* .el-notification-fade-enter {\n    &.right {\n      right: 0;\n      transform: translateX(100%);\n    }\n\n    &.left {\n      left: 0;\n      transform: translateX(-100%);\n    }\n  }\n\n  .el-notification-fade-leave-active {\n    opacity: 0;\n  }*/\n</style>\n"]}, media: undefined });

	    };
	    /* scoped */
	    var __vue_scope_id__$2 = undefined;
	    /* module identifier */
	    var __vue_module_identifier__$2 = undefined;
	    /* functional template */
	    var __vue_is_functional_template__$2 = false;
	    /* component normalizer */
	    function __vue_normalize__$2(
	      template, style, script,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script === 'function' ? script.options : script) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      {
	        var hook;
	        if (style) {
	          hook = function(context) {
	            style.call(this, createInjector(context));
	          };
	        }

	        if (hook !== undefined) {
	          if (component.functional) {
	            // register for functional component in vue file
	            var originalRender = component.render;
	            component.render = function renderWithStyleInjection(h, context) {
	              hook.call(context);
	              return originalRender(h, context)
	            };
	          } else {
	            // inject component registration as beforeCreate hook
	            var existing = component.beforeCreate;
	            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	          }
	        }
	      }

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__$2() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var NotificationLayout = __vue_normalize__$2(
	      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	      __vue_inject_styles__$2,
	      __vue_script__$2,
	      __vue_scope_id__$2,
	      __vue_is_functional_template__$2,
	      __vue_module_identifier__$2,
	      __vue_create_injector__$2,
	      undefined
	    );

	  //
	  //
	  //
	  //
	  //
	  var script$3 = {
	    name: 'VDialogOverlay',
	    props: {
	      zIndex: {
	        type: Number,
	        default: function () { return 1250; }
	      },
	      visible: {
	        type: Boolean,
	        default: function () { return false; }
	      }
	    }
	  };

	  /* script */
	              var __vue_script__$3 = script$3;
	              
	  /* template */
	  var __vue_render__$3 = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("transition", { attrs: { name: "opacity" } }, [
	      _vm.visible
	        ? _c(
	            "div",
	            {
	              staticClass: "dialog-overlay-loading",
	              style: { zIndex: _vm.zIndex }
	            },
	            [_vm._v("Loading…")]
	          )
	        : _vm._e()
	    ])
	  };
	  var __vue_staticRenderFns__$3 = [];
	  __vue_render__$3._withStripped = true;

	    /* style */
	    var __vue_inject_styles__$3 = function (inject) {
	      if (!inject) { return }
	      inject("data-v-05d353e2_0", { source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Absolute Center Spinner */\n.dialog-overlay-loading {\n  position: fixed;\n  z-index: 999;\n  height: 2em;\n  width: 2em;\n  overflow: show;\n  margin: auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  /* background: rgba(112, 112, 112, 0.4); */\n  cursor: wait;\n}\n\n/* Transparent Overlay */\n.dialog-overlay-loading:before {\n  content: '';\n  display: block;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n}\n\n/* :not(:required) hides these rules from IE9 and below */\n.dialog-overlay-loading:not(:required) {\n  /* hide \"loading...\" text */\n  font: 0/0 a;\n  color: transparent;\n  text-shadow: none;\n  background-color: transparent;\n  border: 0;\n}\n.dialog-overlay-loading:not(:required):after {\n  content: '';\n  display: block;\n  font-size: 10px;\n  width: 1em;\n  height: 1em;\n  margin-top: -0.5em;\n  -webkit-animation: spinner 1500ms infinite linear;\n  -moz-animation: spinner 1500ms infinite linear;\n  -ms-animation: spinner 1500ms infinite linear;\n  -o-animation: spinner 1500ms infinite linear;\n  animation: spinner 1500ms infinite linear;\n  border-radius: 0.5em;\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\n}\n\n/* Animation */\n@-webkit-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@-moz-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@-o-keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n@keyframes spinner {\n0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n}\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA,6BAAA;AACA;EACA,gBAAA;EACA,aAAA;EACA,YAAA;EACA,WAAA;EACA,eAAA;EACA,aAAA;EACA,OAAA;EACA,QAAA;EACA,UAAA;EACA,SAAA;EACA,2CAAA;EACA,aAAA;CACA;;AAEA,yBAAA;AACA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,OAAA;EACA,QAAA;EACA,YAAA;EACA,aAAA;EACA,4EAAA;EACA,oFAAA;CACA;;AAEA,0DAAA;AACA;EACA,4BAAA;EACA,YAAA;EACA,mBAAA;EACA,kBAAA;EACA,8BAAA;EACA,UAAA;CACA;AAEA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,WAAA;EACA,YAAA;EACA,mBAAA;EACA,kDAAA;EACA,+CAAA;EACA,8CAAA;EACA,6CAAA;EACA,0CAAA;EACA,qBAAA;EACA,iVAAA;AACA,yUAAA;CACA;;AAEA,eAAA;AAEA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA","file":"DialogOverlay.vue","sourcesContent":["<template>\n  <transition name=\"opacity\">\n    <div class=\"dialog-overlay-loading\" :style=\"{zIndex: zIndex}\" v-if=\"visible\">Loading&#8230;</div>\n  </transition>\n</template>\n<script>\nexport default {\n  name: 'VDialogOverlay',\n  props: {\n    zIndex: {\n      type: Number,\n      default: () => 1250\n    },\n    visible: {\n      type: Boolean,\n      default: () => false\n    }\n  }\n}\n</script>\n<style>\n/* Absolute Center Spinner */\n.dialog-overlay-loading {\n  position: fixed;\n  z-index: 999;\n  height: 2em;\n  width: 2em;\n  overflow: show;\n  margin: auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  /* background: rgba(112, 112, 112, 0.4); */\n  cursor: wait;\n}\n\n/* Transparent Overlay */\n.dialog-overlay-loading:before {\n  content: '';\n  display: block;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\n}\n\n/* :not(:required) hides these rules from IE9 and below */\n.dialog-overlay-loading:not(:required) {\n  /* hide \"loading...\" text */\n  font: 0/0 a;\n  color: transparent;\n  text-shadow: none;\n  background-color: transparent;\n  border: 0;\n}\n\n.dialog-overlay-loading:not(:required):after {\n  content: '';\n  display: block;\n  font-size: 10px;\n  width: 1em;\n  height: 1em;\n  margin-top: -0.5em;\n  -webkit-animation: spinner 1500ms infinite linear;\n  -moz-animation: spinner 1500ms infinite linear;\n  -ms-animation: spinner 1500ms infinite linear;\n  -o-animation: spinner 1500ms infinite linear;\n  animation: spinner 1500ms infinite linear;\n  border-radius: 0.5em;\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\n}\n\n/* Animation */\n\n@-webkit-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-moz-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-o-keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@keyframes spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    -o-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    -o-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n</style>\n"]}, media: undefined });

	    };
	    /* scoped */
	    var __vue_scope_id__$3 = undefined;
	    /* module identifier */
	    var __vue_module_identifier__$3 = undefined;
	    /* functional template */
	    var __vue_is_functional_template__$3 = false;
	    /* component normalizer */
	    function __vue_normalize__$3(
	      template, style, script,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script === 'function' ? script.options : script) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      {
	        var hook;
	        if (style) {
	          hook = function(context) {
	            style.call(this, createInjector(context));
	          };
	        }

	        if (hook !== undefined) {
	          if (component.functional) {
	            // register for functional component in vue file
	            var originalRender = component.render;
	            component.render = function renderWithStyleInjection(h, context) {
	              hook.call(context);
	              return originalRender(h, context)
	            };
	          } else {
	            // inject component registration as beforeCreate hook
	            var existing = component.beforeCreate;
	            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	          }
	        }
	      }

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__$3() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var DialogOverlay = __vue_normalize__$3(
	      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	      __vue_inject_styles__$3,
	      __vue_script__$3,
	      __vue_scope_id__$3,
	      __vue_is_functional_template__$3,
	      __vue_module_identifier__$3,
	      __vue_create_injector__$3,
	      undefined
	    );

	  var Confirmable = {
	    name: 'Confirmable',
	    props: {
	      type: {
	        type: String
	      },
	      text: {
	        type: String,
	        reqiured: true
	      },
	      title: {
	        type: String
	      },
	      actions: {
	        type: [Array, Object]
	      }
	    }
	  };

	  /* @vue/component */
	  var Returnable = {
	    name: 'Returnable',
	    props: {
	      returnValue: null
	    },

	    data: function data() {
	      return {
	        originalValue: this.returnValue,
	        returnResovers: []
	      };
	    },

	    // watch: {
	    //   'wrapper.isActive' (val) {
	    //     console.log('watch.isActive', val)
	    //     if (val) {
	    //       this.originalValue = this.returnValue
	    //     } else {
	    //       // console.log('emit', this.originalValue)
	    //       // this.$emit('submit', this.originalValue)
	    //       this.$emit('update:returnValue', this.originalValue)
	    //     }
	    //   }
	    // },
	    methods: {
	      return: function return$1(value) {
	        this.originalValue = value;
	        this.$root.$emit('submit', this.originalValue);
	        this.$emit('submit', this.originalValue);
	      }

	    }
	  };

	  var Actionable = {
	    name: 'Actionable',
	    mixins: [Returnable],

	    data: function data() {
	      return {
	        loadingAction: null
	      };
	    },

	    props: {
	      actions: {
	        type: [Array, Object],
	        default: function () { return []; }
	      }
	    },
	    computed: {
	      actionlist: function actionlist() {
	        var this$1 = this;

	        var actions = [];

	        for (var key in this$1.actions) {
	          var action = this$1.actions[key];

	          if (typeof action === 'string') {
	            action = {
	              text: action
	            };
	          }

	          this$1.$set(action, 'loading', false);

	          if (!action.key) {
	            action.key = isNaN(key) ? key : action.text;
	          }

	          if (['true', 'false'].indexOf(action.key) >= 0) {
	            action.key = JSON.parse(action.key);
	          }

	          actions.push(action);
	        }

	        return actions;
	      }

	    },
	    methods: {
	      trigger: function trigger(name) {
	        var action = this.actionlist.find(function (action) { return action.key === name; });

	        if (action && !this.isActionDisabled(action) && this.isActionVisible(action)) {
	          this.onActionClick(action);
	        }
	      },

	      setLoadingToInstance: function setLoadingToInstance(vm, value) {
	        if (vm && vm.loading !== undefined) {
	          vm.loading = value;
	        }
	      },

	      setLoadingState: function setLoadingState(value) {
	        this.$emit('loading', value);
	        !value && (this.loadingAction = null);
	        this.setLoadingToInstance(this.$root, value);
	        this.setLoadingToInstance(this.$root._dialogInstance, value);
	      },

	      isActionDisabled: function isActionDisabled(action) {
	        if (action.disabled === undefined) {
	          return false;
	        }

	        if (typeof action.disabled === 'function') {
	          return action.disabled();
	        }

	        return action.disabled;
	      },

	      isActionVisible: function isActionVisible(action) {
	        if (action.visible === undefined) {
	          return true;
	        }

	        if (typeof action.visible === 'function') {
	          return action.visible();
	        }

	        return action.visible;
	      },

	      onActionClick: function onActionClick(action) {
	        return new Promise(function ($return, $error) {
	          var closable;
	          closable = action.closable === undefined || action.closable === true;

	          if (action.handle) {
	            this.loadingAction = action.key;
	            this.setLoadingState(true);

	            var $Try_1_Post = function () {
	              try {
	                return $If_2.call(this);
	              } catch ($boundEx) {
	                return $error($boundEx);
	              }
	            }.bind(this);

	            var $Try_1_Catch = function (e) {
	              try {
	                this.setLoadingState(false);
	                console.log('error', e); // TODO

	                throw e;
	              } catch ($boundEx) {
	                return $error($boundEx);
	              }
	            }.bind(this);

	            try {
	              var ret;
	              return Promise.resolve(action.handle()).then(function ($await_3) {
	                try {
	                  ret = $await_3;
	                  this.setLoadingState(false);

	                  if (ret !== false && closable) {
	                    this.return(ret || action.key);
	                  }

	                  return $Try_1_Post();
	                } catch ($boundEx) {
	                  return $Try_1_Catch($boundEx);
	                }
	              }.bind(this), $Try_1_Catch);
	            } catch (e) {
	              $Try_1_Catch(e);
	            }
	          } else {
	            closable && this.return(action.key);
	            return $If_2.call(this);
	          }

	          function $If_2() {
	            return $return();
	          }
	        }.bind(this));
	      }

	    }
	  };

	  //
	  var script$4 = {
	    mixins: [Actionable]
	  };

	  /* script */
	              var __vue_script__$4 = script$4;
	              
	  /* template */
	  var __vue_render__$4 = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c(
	      "span",
	      _vm._l(_vm.actionlist, function(action) {
	        return _c(
	          "button",
	          {
	            key: action.key,
	            staticClass: "button",
	            class: { loading: _vm.loadingAction === action.key },
	            attrs: {
	              "action-key": "" + action.key,
	              disabled: _vm.isActionDisabled(action) || !!_vm.loadingAction
	            },
	            on: {
	              click: function($event) {
	                _vm.onActionClick(action);
	              }
	            }
	          },
	          [_vm._v("\n    " + _vm._s(action.text) + "\n  ")]
	        )
	      })
	    )
	  };
	  var __vue_staticRenderFns__$4 = [];
	  __vue_render__$4._withStripped = true;

	    /* style */
	    var __vue_inject_styles__$4 = undefined;
	    /* scoped */
	    var __vue_scope_id__$4 = undefined;
	    /* module identifier */
	    var __vue_module_identifier__$4 = undefined;
	    /* functional template */
	    var __vue_is_functional_template__$4 = false;
	    /* component normalizer */
	    function __vue_normalize__$4(
	      template, style, script,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script === 'function' ? script.options : script) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/DialogActions.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__$4() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var DialogActions = __vue_normalize__$4(
	      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	      __vue_inject_styles__$4,
	      __vue_script__$4,
	      __vue_scope_id__$4,
	      __vue_is_functional_template__$4,
	      __vue_module_identifier__$4,
	      __vue_create_injector__$4,
	      undefined
	    );

	  //
	  var script$5 = {
	    components: {
	      DialogActions: DialogActions
	    },
	    layout: 'default',
	    mixins: [Confirmable]
	  };

	  /* script */
	              var __vue_script__$5 = script$5;
	              
	  /* template */
	  var __vue_render__$5 = function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "confirm-box" }, [
	      !!_vm.title
	        ? _c("div", { staticClass: "confirm-title" }, [
	            _c("h1", { staticClass: "title" }, [_vm._v(_vm._s(_vm.title))])
	          ])
	        : _vm._e(),
	      _vm._v(" "),
	      _c("div", {
	        staticClass: "confirm-message",
	        domProps: { innerHTML: _vm._s(_vm.message) }
	      }),
	      _vm._v(" "),
	      _c("div", { staticClass: "confirm-buttons" }, [
	        _c(
	          "div",
	          { staticClass: "column" },
	          [_c("DialogActions", { attrs: { actions: _vm.actions } })],
	          1
	        )
	      ])
	    ])
	  };
	  var __vue_staticRenderFns__$5 = [];
	  __vue_render__$5._withStripped = true;

	    /* style */
	    var __vue_inject_styles__$5 = function (inject) {
	      if (!inject) { return }
	      inject("data-v-8a87651c_0", { source: "\n.confirm-box {\n  background: #ffffff;\n}\n.confirm-box .confirm-title {\n  padding: 20px\n}\n.confirm-box .confirm-message {\n  padding: 0 20px;\n}\n.confirm-box .confirm-buttons {\n  text-align:  right;\n  padding: 10px 20px;\n}\n.confirm-box .confirm-buttons .button {\n  font-size: 20px;\n  padding-left: 20px;\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue"],"names":[],"mappings":";AA6BA;EACA,oBAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,mBAAA;EACA,mBAAA;CACA;AACA;EACA,gBAAA;EACA,mBAAA;CACA","file":"Confirm.vue","sourcesContent":["<template>\n  <div class=\"confirm-box\">\n    <div v-if=\"!!title\" class=\"confirm-title\">\n      <h1 class=\"title\">{{ title }}</h1>\n    </div>\n    <div class=\"confirm-message\" v-html=\"message\" />\n    <div class=\"confirm-buttons\">\n      <div class=\"column\">\n        <DialogActions :actions=\"actions\"/>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\n\nimport Confirmable from '../mixins/confirmable'\nimport DialogActions from './DialogActions.vue'\n\nexport default {\n  components: {\n    DialogActions\n  },\n  layout: 'default',\n  mixins: [ Confirmable ]\n}\n\n</script>\n\n<style>\n  .confirm-box {\n    background: #ffffff;\n  }\n  .confirm-box .confirm-title {\n    padding: 20px\n  }\n  .confirm-box .confirm-message {\n    padding: 0 20px;\n  }\n  .confirm-box .confirm-buttons {\n    text-align:  right;\n    padding: 10px 20px;\n  }\n  .confirm-box .confirm-buttons .button {\n    font-size: 20px;\n    padding-left: 20px;\n  }\n</style>\n"]}, media: undefined });

	    };
	    /* scoped */
	    var __vue_scope_id__$5 = undefined;
	    /* module identifier */
	    var __vue_module_identifier__$5 = undefined;
	    /* functional template */
	    var __vue_is_functional_template__$5 = false;
	    /* component normalizer */
	    function __vue_normalize__$5(
	      template, style, script,
	      scope, functional, moduleIdentifier,
	      createInjector, createInjectorSSR
	    ) {
	      var component = (typeof script === 'function' ? script.options : script) || {};

	      // For security concerns, we use only base name in production mode.
	      component.__file = "/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue";

	      if (!component.render) {
	        component.render = template.render;
	        component.staticRenderFns = template.staticRenderFns;
	        component._compiled = true;

	        if (functional) { component.functional = true; }
	      }

	      component._scopeId = scope;

	      {
	        var hook;
	        if (style) {
	          hook = function(context) {
	            style.call(this, createInjector(context));
	          };
	        }

	        if (hook !== undefined) {
	          if (component.functional) {
	            // register for functional component in vue file
	            var originalRender = component.render;
	            component.render = function renderWithStyleInjection(h, context) {
	              hook.call(context);
	              return originalRender(h, context)
	            };
	          } else {
	            // inject component registration as beforeCreate hook
	            var existing = component.beforeCreate;
	            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	          }
	        }
	      }

	      return component
	    }
	    /* style inject */
	    function __vue_create_injector__$5() {
	      var head = document.head || document.getElementsByTagName('head')[0];
	      var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
	      var isOldIE =
	        typeof navigator !== 'undefined' &&
	        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	      return function addStyle(id, css) {
	        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	        var group = isOldIE ? css.media || 'default' : id;
	        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	        if (!style.ids.includes(id)) {
	          var code = css.source;
	          var index = style.ids.length;

	          style.ids.push(id);

	          if (isOldIE) {
	            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	          }

	          if (!style.element) {
	            var el = style.element = document.createElement('style');
	            el.type = 'text/css';

	            if (css.media) { el.setAttribute('media', css.media); }
	            if (isOldIE) {
	              el.setAttribute('data-group', group);
	              el.setAttribute('data-next-index', '0');
	            }

	            head.appendChild(el);
	          }

	          if (isOldIE) {
	            index = parseInt(style.element.getAttribute('data-next-index'));
	            style.element.setAttribute('data-next-index', index + 1);
	          }

	          if (style.element.styleSheet) {
	            style.parts.push(code);
	            style.element.styleSheet.cssText = style.parts
	              .filter(Boolean)
	              .join('\n');
	          } else {
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index]) { style.element.removeChild(nodes[index]); }
	            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	            else { style.element.appendChild(textNode); }
	          }
	        }
	      }
	    }
	    /* style inject SSR */
	    

	    
	    var Confirm = __vue_normalize__$5(
	      { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
	      __vue_inject_styles__$5,
	      __vue_script__$5,
	      __vue_scope_id__$5,
	      __vue_is_functional_template__$5,
	      __vue_module_identifier__$5,
	      __vue_create_injector__$5,
	      undefined
	    );

	  /*
	   * vuedl
	   *
	   * (c) Savaryn Yaroslav <yariksav@gmail.com>
	   *
	   * For the full copyright and license information, please view the LICENSE
	   * file that was distributed with this source code.
	  */
	  var Plugin = {
	    install: function install(Vue$$1, options) {
	      if ( options === void 0 ) options = {};

	      var property = options.property || '$dialog';
	      var manager = new DialogManager(options); // const no = new Notificator(manager)

	      Object.defineProperty(Vue$$1.prototype, property, {
	        get: function get() {
	          return manager;
	        }

	      });
	      manager.layout('default', DialogLayout);
	      manager.layout('notification', NotificationLayout);
	      manager.overlay('default', DialogOverlay);
	      manager.component('confirm', Confirm, {
	        waitForResult: true,
	        actions: {
	          'false': 'Cancel',
	          'true': 'OK'
	        }
	      });
	      manager.component('warning', Confirm, {
	        type: 'warning',
	        waitForResult: true,
	        actions: {
	          'false': 'Cancel',
	          'true': 'OK'
	        }
	      });
	      manager.component('error', Confirm, {
	        type: 'error',
	        waitForResult: true,
	        actions: ['OK']
	      });
	    }

	  };

	  return Plugin;

	})));
	});

	/* @vue/component */
	var Returnable = {
	  name: 'Returnable',

	  props: {
	    returnValue: null
	  },

	  data () {
	    return {
	      originalValue: this.returnValue,
	      returnResovers: []
	    }
	  },

	  // watch: {
	  //   'wrapper.isActive' (val) {
	  //     console.log('watch.isActive', val)
	  //     if (val) {
	  //       this.originalValue = this.returnValue
	  //     } else {
	  //       // console.log('emit', this.originalValue)
	  //       // this.$emit('submit', this.originalValue)
	  //       this.$emit('update:returnValue', this.originalValue)
	  //     }
	  //   }
	  // },

	  methods: {
	    return (value) {
	      this.originalValue = value;
	      this.$root.$emit('submit', this.originalValue);
	      this.$emit('submit', this.originalValue);
	    }
	  }
	}

	var Actionable = {
	  name: 'Actionable',

	  mixins: [ Returnable ],

	  data () {
	    return {
	      loadingAction: null
	    }
	  },

	  props: {
	    actions: {
	      type: [Array, Object],
	      default: () => []
	    }
	  },

	  computed: {
	    actionlist () {
	      const actions = [];
	      for (let key in this.actions) {
	        let action = this.actions[key];
	        if (typeof action === 'string') {
	          action = {text: action};
	        }
	        this.$set(action, 'loading', false);
	        if (!action.key) {
	          action.key = isNaN(key) ? key : action.text;
	        }
	        if (['true', 'false'].indexOf(action.key) >= 0) {
	          action.key = JSON.parse(action.key);
	        }
	        actions.push(action);
	      }
	      return actions
	    }
	  },

	  methods: {
	    trigger (name) {
	      const action = this.actionlist.find(action => action.key === name);
	      if (action && !this.isActionDisabled(action) && this.isActionVisible(action)) {
	        this.onActionClick(action);
	      }
	    },
	    setLoadingToInstance (vm, value) {
	      if (vm && vm.loading !== undefined) {
	        vm.loading = value;
	      }
	    },
	    setLoadingState (value) {
	      this.$emit('loading', value);
	      !value && (this.loadingAction = null);
	      this.setLoadingToInstance(this.$root, value);
	      this.setLoadingToInstance(this.$root._dialogInstance, value);
	    },
	    isActionDisabled (action) {
	      if (action.disabled === undefined) {
	        return false
	      }
	      if (typeof action.disabled === 'function') {
	        return action.disabled()
	      }
	      return action.disabled
	    },
	    isActionVisible (action) {
	      if (action.visible === undefined) {
	        return true
	      }
	      if (typeof action.visible === 'function') {
	        return action.visible()
	      }
	      return action.visible
	    },
	    async onActionClick (action) {
	      const closable = action.closable === undefined || action.closable === true;
	      if (action.handle) {
	        this.loadingAction = action.key;
	        this.setLoadingState(true);
	        try {
	          let ret = await action.handle();
	          this.setLoadingState(false);
	          if (ret !== false && closable) {
	            this.return(ret || action.key);
	          }
	        } catch (e) {
	          this.setLoadingState(false);
	          console.log('error', e); // TODO
	          throw e
	        }
	      } else {
	        closable && this.return(action.key);
	      }
	    }
	  }
	}

	//
	//
	//
	//
	//
	//
	//
	//
	var script = {
	  name: 'BeatLoader',
	  props: {
	    loading: {
	      type: Boolean,
	      default: true
	    },
	    color: {
	      type: String,
	      default: '#5dc596'
	    },
	    size: {
	      type: String,
	      default: '15px'
	    },
	    margin: {
	      type: String,
	      default: '2px'
	    },
	    radius: {
	      type: String,
	      default: '100%'
	    }
	  },

	  data: function data() {
	    return {
	      spinnerStyle: {
	        backgroundColor: this.color,
	        height: this.size,
	        width: this.size,
	        margin: this.margin,
	        borderRadius: this.radius
	      }
	    };
	  }

	};

	/* script */
	            var __vue_script__ = script;
	            
	/* template */
	var __vue_render__ = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      directives: [
	        {
	          name: "show",
	          rawName: "v-show",
	          value: _vm.loading,
	          expression: "loading"
	        }
	      ],
	      staticClass: "v-spinner"
	    },
	    [
	      _c("div", { staticClass: "v-beat v-beat-odd", style: _vm.spinnerStyle }),
	      _vm._v(" "),
	      _c("div", { staticClass: "v-beat v-beat-even", style: _vm.spinnerStyle }),
	      _vm._v(" "),
	      _c("div", { staticClass: "v-beat v-beat-odd", style: _vm.spinnerStyle })
	    ]
	  )
	};
	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;

	  /* style */
	  var __vue_inject_styles__ = function (inject) {
	    if (!inject) { return }
	    inject("data-v-7929aa72_0", { source: "\n.v-spinner .v-beat\n{\n    -webkit-animation: v-beatStretchDelay 0.7s infinite linear;\n            animation: v-beatStretchDelay 0.7s infinite linear;\n    -webkit-animation-fill-mode: both;\n            animation-fill-mode: both;\n    display: inline-block;\n}\n.v-spinner .v-beat-odd\n{\n  animation-delay: 0s;\n}\n.v-spinner .v-beat-even\n{\n  animation-delay: 0.35s;\n}\n@-webkit-keyframes v-beatStretchDelay\n{\n50%\n    {\n        -webkit-transform: scale(0.75);\n                transform: scale(0.75);\n        -webkit-opacity: 0.2;\n                opacity: 0.2;\n}\n100%\n    {\n        -webkit-transform: scale(1);\n                transform: scale(1);\n        -webkit-opacity: 1;\n                opacity: 1;\n}\n}\n@keyframes v-beatStretchDelay\n{\n50%\n    {\n        -webkit-transform: scale(0.75);\n                transform: scale(0.75);\n        -webkit-opacity: 0.2;\n                opacity: 0.2;\n}\n100%\n    {\n        -webkit-transform: scale(1);\n                transform: scale(1);\n        -webkit-opacity: 1;\n                opacity: 1;\n}\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Loader.vue"],"names":[],"mappings":";AAmDA;;IAEA,2DAAA;YACA,mDAAA;IACA,kCAAA;YACA,0BAAA;IACA,sBAAA;CACA;AAEA;;EAEA,oBAAA;CACA;AACA;;EAEA,uBAAA;CACA;AAEA;;AAEA;;QAEA,+BAAA;gBACA,uBAAA;QACA,qBAAA;gBACA,aAAA;CACA;AACA;;QAEA,4BAAA;gBACA,oBAAA;QACA,mBAAA;gBACA,WAAA;CACA;CACA;AAEA;;AAEA;;QAEA,+BAAA;gBACA,uBAAA;QACA,qBAAA;gBACA,aAAA;CACA;AACA;;QAEA,4BAAA;gBACA,oBAAA;QACA,mBAAA;gBACA,WAAA;CACA;CACA","file":"Loader.vue","sourcesContent":["<template>\n  <div class=\"v-spinner\" v-show=\"loading\">\n    <div class=\"v-beat v-beat-odd\" :style=\"spinnerStyle\"/>\n    <div class=\"v-beat v-beat-even\" :style=\"spinnerStyle\"/>\n    <div class=\"v-beat v-beat-odd\" :style=\"spinnerStyle\"/>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BeatLoader',\n\n  props: {\n    loading: {\n      type: Boolean,\n      default: true\n    },\n    color: {\n      type: String,\n      default: '#5dc596'\n    },\n    size: {\n      type: String,\n      default: '15px'\n    },\n    margin: {\n      type: String,\n      default: '2px'\n    },\n    radius: {\n      type: String,\n      default: '100%'\n    }\n  },\n  data () {\n    return {\n      spinnerStyle: {\n        backgroundColor: this.color,\n        height: this.size,\n        width: this.size,\n        margin: this.margin,\n        borderRadius: this.radius\n      }\n    }\n  }\n\n}\n</script>\n\n<style>\n\n.v-spinner .v-beat\n{\n    -webkit-animation: v-beatStretchDelay 0.7s infinite linear;\n            animation: v-beatStretchDelay 0.7s infinite linear;\n    -webkit-animation-fill-mode: both;\n            animation-fill-mode: both;\n    display: inline-block;\n}\n\n.v-spinner .v-beat-odd\n{\n  animation-delay: 0s;\n}\n.v-spinner .v-beat-even\n{\n  animation-delay: 0.35s;\n}\n\n@-webkit-keyframes v-beatStretchDelay\n{\n    50%\n    {\n        -webkit-transform: scale(0.75);\n                transform: scale(0.75);\n        -webkit-opacity: 0.2;\n                opacity: 0.2;\n    }\n    100%\n    {\n        -webkit-transform: scale(1);\n                transform: scale(1);\n        -webkit-opacity: 1;\n                opacity: 1;\n    }\n}\n\n@keyframes v-beatStretchDelay\n{\n    50%\n    {\n        -webkit-transform: scale(0.75);\n                transform: scale(0.75);\n        -webkit-opacity: 0.2;\n                opacity: 0.2;\n    }\n    100%\n    {\n        -webkit-transform: scale(1);\n                transform: scale(1);\n        -webkit-opacity: 1;\n                opacity: 1;\n    }\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__ = undefined;
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* component normalizer */
	  function __vue_normalize__(
	    template, style, script$$1,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Loader.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var Loader = __vue_normalize__(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    __vue_create_injector__,
	    undefined
	  )

	//
	var script$1 = {
	  components: {
	    Loader: Loader
	  },
	  mixins: [Actionable],
	  props: {
	    variant: {
	      type: String,
	      default: 'outline-primary'
	    }
	  }
	};

	/* script */
	            var __vue_script__$1 = script$1;
	            
	/* template */
	var __vue_render__$1 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "span",
	    { staticClass: "dialog-actions" },
	    _vm._l(_vm.actionlist, function(action) {
	      return _c(
	        "b-btn",
	        {
	          key: action.key,
	          attrs: {
	            variant: action.variant || _vm.variant,
	            loading: _vm.loadingAction === action.key,
	            disabled: _vm.isActionDisabled(action) || !!_vm.loadingAction
	          },
	          on: {
	            click: function($event) {
	              _vm.onActionClick(action);
	            }
	          }
	        },
	        [
	          _vm.loadingAction === action.key
	            ? _c("Loader", { attrs: { size: "8px" } })
	            : [_vm._v(_vm._s(action.text))]
	        ],
	        2
	      )
	    })
	  )
	};
	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$1 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-b0725018_0", { source: "\n.dialog-actions button {\n   margin-right: 4px;\n   margin-right: .25rem;\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogActions.vue"],"names":[],"mappings":";AA+BA;GACA,kBAAA;GACA,qBAAA;CACA","file":"DialogActions.vue","sourcesContent":["<template>\n  <span class=\"dialog-actions\">\n    <b-btn v-for=\"action in actionlist\" :key=\"action.key\"\n      :variant=\"action.variant || variant\"\n      :loading=\"loadingAction === action.key\"\n      :disabled=\"isActionDisabled(action) || !!loadingAction\"\n      @click=\"onActionClick(action)\">\n      <Loader v-if=\"loadingAction === action.key\" size=\"8px\"/>\n      <template v-else>{{ action.text }}</template>\n    </b-btn>\n  </span>\n</template>\n<script>\n\nimport Actionable from 'vuedl/src/mixins/actionable'\nimport Loader from './Loader.vue'\n\nexport default {\n  components: {\n    Loader\n  },\n  mixins: [ Actionable ],\n  props: {\n    variant: {\n      type: String,\n      default: 'outline-primary'\n    }\n  }\n}\n</script>\n<style>\n  .dialog-actions button {\n     margin-right: 4px;\n     margin-right: .25rem;\n  }\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$1 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$1 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$1 = false;
	  /* component normalizer */
	  function __vue_normalize__$1(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogActions.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$1() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var DialogActions = __vue_normalize__$1(
	    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	    __vue_inject_styles__$1,
	    __vue_script__$1,
	    __vue_scope_id__$1,
	    __vue_is_functional_template__$1,
	    __vue_module_identifier__$1,
	    __vue_create_injector__$1,
	    undefined
	  )

	//
	var zIndex = 1100;
	var script$2 = {
	  components: {
	    DialogActions: DialogActions
	  },
	  props: {
	    size: {
	      type: String,
	      default: function () {
	        'md';
	      }
	    },
	    title: String,
	    actions: [Array, Object],
	    hideBackdrop: Boolean,
	    centered: Boolean
	  },
	  methods: {
	    _destroy: function _destroy() {// stub
	    },

	    onModalHidden: function onModalHidden() {
	      zIndex = zIndex - 2;
	      this.$destroy();
	    },

	    onModalShown: function onModalShown(ev) {
	      var parent = ev.target.parentElement;
	      var backdrop = parent.querySelector('.modal-backdrop');
	      backdrop && backdrop.style && (backdrop.style['z-index'] = ++zIndex);
	      var modal = parent.querySelector('.modal');
	      modal && modal.style && (modal.style['z-index'] = ++zIndex);
	    }

	  }
	};

	/* script */
	            var __vue_script__$2 = script$2;
	            
	/* template */
	var __vue_render__$2 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "b-modal",
	    {
	      staticClass: "dialog-layout",
	      attrs: {
	        "hide-header": "",
	        "hide-footer": "",
	        "hide-backdrop": _vm.hideBackdrop,
	        centered: _vm.centered,
	        size: _vm.size,
	        "body-class": "dialog-layout-modal-body",
	        "no-close-on-backdrop": _vm.persistent || _vm.loading,
	        "no-close-on-esc": _vm.persistent || _vm.loading
	      },
	      on: { hidden: _vm.onModalHidden, shown: _vm.onModalShown },
	      model: {
	        value: _vm.isActive,
	        callback: function($$v) {
	          _vm.isActive = $$v;
	        },
	        expression: "isActive"
	      }
	    },
	    [_vm._t("default")],
	    2
	  )
	};
	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$2 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-0f764872_0", { source: "\n.dialog-layout-modal-body {\n  padding: 0;\n}\n", map: {"version":3,"sources":["/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogLayout.vue"],"names":[],"mappings":";AAwDA;EACA,WAAA;CACA","file":"DialogLayout.vue","sourcesContent":["<template>\n  <b-modal v-model=\"isActive\"\n    class=\"dialog-layout\"\n    hide-header\n    hide-footer\n    :hide-backdrop=\"hideBackdrop\"\n    :centered=\"centered\"\n    :size=\"size\"\n    body-class=\"dialog-layout-modal-body\"\n    :no-close-on-backdrop=\"persistent || loading\"\n    :no-close-on-esc=\"persistent || loading\"\n    @hidden=\"onModalHidden\"\n    @shown=\"onModalShown\">\n    <slot/>\n  </b-modal>\n</template>\n\n<script>\n\nimport DialogActions from './DialogActions.vue'\n\nlet zIndex = 1100\n\nexport default {\n  components: {\n    DialogActions\n  },\n  props: {\n    size: {\n      type: String,\n      default: () => { 'md' }\n    },\n    title: String,\n    actions: [Array, Object],\n    hideBackdrop: Boolean,\n    centered: Boolean\n  },\n  methods: {\n    _destroy () {\n      // stub\n    },\n    onModalHidden () {\n      zIndex = zIndex - 2\n      this.$destroy()\n    },\n    onModalShown (ev) {\n      const parent = ev.target.parentElement\n      const backdrop = parent.querySelector('.modal-backdrop')\n      backdrop && backdrop.style && (backdrop.style['z-index'] = ++zIndex)\n      const modal = parent.querySelector('.modal')\n      modal && modal.style && (modal.style['z-index'] = ++zIndex)\n    }\n  }\n}\n</script>\n<style>\n  .dialog-layout-modal-body {\n    padding: 0;\n  }\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$2 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$2 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$2 = false;
	  /* component normalizer */
	  function __vue_normalize__$2(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogLayout.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$2() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var DialogLayout = __vue_normalize__$2(
	    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	    __vue_inject_styles__$2,
	    __vue_script__$2,
	    __vue_scope_id__$2,
	    __vue_is_functional_template__$2,
	    __vue_module_identifier__$2,
	    __vue_create_injector__$2,
	    undefined
	  )

	var Confirmable = {
	  name: 'Confirmable',

	  props: {
	    type: {
	      type: String
	    },
	    text: {
	      type: String,
	      reqiured: true
	    },
	    title: {
	      type: String
	    },
	    actions: {
	      type: [Array, Object]
	    }
	  }
	}

	var Colorable = {
	  props: {
	    type: String,
	    color: String
	  },
	  computed: {
	    getColor: function getColor() {
	      return this.color || this.type;
	    }

	  }
	};

	//
	var script$3 = {
	  components: {
	    DialogActions: DialogActions
	  },
	  layout: 'default',
	  mixins: [Confirmable, Colorable],
	  computed: {
	    headerTextVariant: function headerTextVariant() {
	      return ['info', 'danger'].indexOf(this.type) >= 0 ? 'light' : 'dark';
	    }

	  }
	};

	/* script */
	            var __vue_script__$3 = script$3;
	            
	/* template */
	var __vue_render__$3 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _c(
	        "DialogCard",
	        {
	          attrs: {
	            actions: _vm.actions,
	            title: _vm.title,
	            "header-bg-variant": _vm.type,
	            "header-text-variant": _vm.headerTextVariant
	          }
	        },
	        [
	          _c("div", {
	            staticClass: "dialog-confirm-text",
	            domProps: { innerHTML: _vm._s(_vm.text) }
	          })
	        ]
	      )
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$3 = undefined;
	  /* scoped */
	  var __vue_scope_id__$3 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$3 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$3 = false;
	  /* component normalizer */
	  function __vue_normalize__$3(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Confirm.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var Confirm = __vue_normalize__$3(
	    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	    __vue_inject_styles__$3,
	    __vue_script__$3,
	    __vue_scope_id__$3,
	    __vue_is_functional_template__$3,
	    __vue_module_identifier__$3,
	    undefined,
	    undefined
	  )

	//
	var script$4 = {
	  components: {
	    DialogActions: DialogActions
	  },
	  layout: ['notification', {
	    showClose: false
	  }],
	  props: {
	    type: {
	      type: String,
	      default: function () { return 'info'; }
	    },
	    actions: [Array, Object],
	    text: String,
	    dismissible: {
	      type: Boolean,
	      default: true
	    }
	  }
	};

	/* script */
	            var __vue_script__$4 = script$4;
	            
	/* template */
	var __vue_render__$4 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "b-alert",
	    {
	      staticStyle: { "margin-bottom": "0" },
	      attrs: { show: "", variant: _vm.type, dismissible: _vm.dismissible },
	      on: {
	        dismissed: function($event) {
	          _vm.$emit("submit");
	        }
	      }
	    },
	    [_c("span", { domProps: { innerHTML: _vm._s(_vm.text) } })]
	  )
	};
	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$4 = undefined;
	  /* scoped */
	  var __vue_scope_id__$4 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$4 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$4 = false;
	  /* component normalizer */
	  function __vue_normalize__$4(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Alert.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var Alert = __vue_normalize__$4(
	    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	    __vue_inject_styles__$4,
	    __vue_script__$4,
	    __vue_scope_id__$4,
	    __vue_is_functional_template__$4,
	    __vue_module_identifier__$4,
	    undefined,
	    undefined
	  )

	//
	var script$5 = {
	  components: {
	    DialogActions: DialogActions
	  },
	  props: {
	    title: String,
	    actions: [Array, Object],
	    headerBgVariant: String,
	    headerTextVariant: String,
	    headerBorderVariant: String,
	    headerClass: String
	  },
	  computed: {
	    headerClasses: function headerClasses() {
	      var obj;

	      return ['modal-header', ( obj = {}, obj[("bg-" + (this.headerBgVariant))] = Boolean(this.headerBgVariant), obj[("text-" + (this.headerTextVariant))] = Boolean(this.headerTextVariant), obj[("border-" + (this.headerBorderVariant))] = Boolean(this.headerBorderVariant), obj), this.headerClass];
	    }

	  },
	  methods: {
	    trigger: function trigger(name) {
	      this.$refs.actions && this.$refs.actions.trigger(name);
	    }

	  }
	};

	/* script */
	            var __vue_script__$5 = script$5;
	            
	/* template */
	var __vue_render__$5 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", [
	    _c(
	      "header",
	      { class: _vm.headerClasses },
	      [
	        _vm._t("title", [
	          _c("h5", { staticClass: "modal-title" }, [_vm._v(_vm._s(_vm.title))])
	        ]),
	        _vm._v(" "),
	        _c(
	          "button",
	          {
	            staticClass: "close",
	            attrs: { type: "button", "aria-label": "Close" }
	          },
	          [_vm._v("×")]
	        )
	      ],
	      2
	    ),
	    _vm._v(" "),
	    _c("div", { staticClass: "modal-body" }, [_vm._t("default")], 2),
	    _vm._v(" "),
	    _vm.actions
	      ? _c(
	          "footer",
	          { staticClass: "modal-footer" },
	          [
	            _c("DialogActions", {
	              ref: "actions",
	              attrs: { actions: _vm.actions }
	            })
	          ],
	          1
	        )
	      : _vm._e()
	  ])
	};
	var __vue_staticRenderFns__$5 = [];
	__vue_render__$5._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$5 = undefined;
	  /* scoped */
	  var __vue_scope_id__$5 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$5 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$5 = false;
	  /* component normalizer */
	  function __vue_normalize__$5(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogCard.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var DialogCard = __vue_normalize__$5(
	    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
	    __vue_inject_styles__$5,
	    __vue_script__$5,
	    __vue_scope_id__$5,
	    __vue_is_functional_template__$5,
	    __vue_module_identifier__$5,
	    undefined,
	    undefined
	  )

	//
	var script$6 = {
	  components: {
	    DialogCard: DialogCard
	  },
	  layout: 'default',
	  mixins: [Confirmable],
	  props: {
	    value: String
	  },
	  computed: {
	    parsedActions: function parsedActions() {
	      var actions = this.actions;

	      if (actions[true]) {
	        if (typeof actions[true] === 'string') {
	          actions[true] = {
	            'text': actions[true],
	            handle: this.onSubmit
	          };
	        } else {
	          actions[true].handle = this.onSubmit;
	        }
	      }

	      return actions;
	    }

	  },

	  data: function data() {
	    return {
	      editedValue: this.value
	    };
	  },

	  methods: {
	    onSubmit: function onSubmit() {
	      this.$emit('submit', this.editedValue);
	    }

	  }
	};

	/* script */
	            var __vue_script__$6 = script$6;
	            
	/* template */
	var __vue_render__$6 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _c(
	        "DialogCard",
	        { attrs: { title: _vm.title, actions: _vm.parsedActions } },
	        [
	          _c("b-form-input", {
	            attrs: { autofocus: "", placeholder: _vm.text, required: "" },
	            on: {
	              keypress: function($event) {
	                if (
	                  !("button" in $event) &&
	                  _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
	                ) {
	                  return null
	                }
	                return _vm.onSubmit($event)
	              }
	            },
	            model: {
	              value: _vm.editedValue,
	              callback: function($$v) {
	                _vm.editedValue = $$v;
	              },
	              expression: "editedValue"
	            }
	          })
	        ],
	        1
	      )
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$6 = [];
	__vue_render__$6._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$6 = undefined;
	  /* scoped */
	  var __vue_scope_id__$6 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$6 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$6 = false;
	  /* component normalizer */
	  function __vue_normalize__$6(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Prompt.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var Prompt = __vue_normalize__$6(
	    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
	    __vue_inject_styles__$6,
	    __vue_script__$6,
	    __vue_scope_id__$6,
	    __vue_is_functional_template__$6,
	    __vue_module_identifier__$6,
	    undefined,
	    undefined
	  )

	var Plugin = {
	  install: function install(Vue, options) {
	    if ( options === void 0 ) options = {};

	    var property = options.property || '$dialog'; // const messageProperty = options.messageProperty

	    Vue.use(vuedl, options);
	    var manager = Vue.prototype[property];
	    manager.layout('default', DialogLayout);
	    Vue.component('DialogActions', DialogActions);
	    Vue.component('DialogCard', DialogCard);
	    manager.on('show', function () {
	      document.body.classList.remove('modal-open');
	    });
	    manager.component('confirm', Confirm, {
	      waitForResult: true,
	      actions: {
	        'false': 'Cancel',
	        'true': 'OK'
	      }
	    });
	    manager.component('warning', Confirm, {
	      type: 'warning',
	      waitForResult: true,
	      actions: {
	        'false': 'Cancel',
	        'true': 'OK'
	      }
	    });
	    manager.component('info', Confirm, {
	      type: 'info',
	      waitForResult: true,
	      actions: {
	        'false': 'Cancel',
	        'true': 'OK'
	      }
	    });
	    manager.component('error', Confirm, {
	      type: 'danger',
	      waitForResult: true,
	      actions: ['Close']
	    }); // manager.component('toast', Toast, {
	    //   waitForResult: true
	    // })
	    // manager.message = {
	    //   info: (message, options) => manager.toast({ text: message, variant: 'info', ...options }),
	    //   error: (message, options) => manager.toast({ text: message, variant: 'danger', ...options }),
	    //   success: (message, options) => manager.toast({ text: message, variant: 'success', ...options }),
	    //   warning: (message, options) => manager.toast({ text: message, variant: 'warning', ...options })
	    // }
	    // messageProperty && (Vue.prototype[messageProperty] = manager.message)

	    manager.component('alert', Alert, {
	      waitForResult: true
	    });
	    manager.notify = {
	      info: function (message, options) { return manager.alert(Object.assign({
	        text: message,
	        type: 'info'
	      }, options)); },
	      error: function (message, options) { return manager.alert(Object.assign({
	        text: message,
	        type: 'danger'
	      }, options)); },
	      success: function (message, options) { return manager.alert(Object.assign({
	        text: message,
	        type: 'success'
	      }, options)); },
	      warning: function (message, options) { return manager.alert(Object.assign({
	        text: message,
	        type: 'warning'
	      }, options)); }
	    };
	    manager.component('prompt', Prompt, {
	      waitForResult: true,
	      actions: {
	        false: 'Cancel',
	        true: 'OK'
	      }
	    });
	  }

	};

	return Plugin;

})));
